<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>heap on Hindung Blogs</title><link>http://hindung.cn/tags/heap/</link><description>Recent content in heap on Hindung Blogs</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 23 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://hindung.cn/tags/heap/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang实现优先队列</title><link>http://hindung.cn/posts/11/</link><pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate><guid>http://hindung.cn/posts/11/</guid><description>前言 # 由于刷题时偶尔会用到队列以及优先队列等数据结构，其他语言都有现成的实现，如C++的priority_queue等，使用非常方便，但是由于个人比较喜欢使用golang语言进行答题，但是go对队列以及优先队列的实现只提供了一个接口，即container/heap包中的heap数据结构，故实现还是要自己去码，这里做一个笔记。实现了heap接口来实现priority_queue，并且提供了其他方法的实现。
heap原理 # go的container/heap包实现的是数据结构是数组构成的二叉树（完全二叉树），如下所示：
// 树中某个节点的值总是不大于或不小于其孩子节点的值； // 树中每个节点的子树都是堆树 // index 0 1 2 3 4 5 6 7 8 9 // index 1 2 3 4 5 6 7 8 9 10 // a[] = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7} // 4 // / \ // 1 3 // / \ / \ // 2 16 9 10 // /\ / // 14 8 7 // 若取a[1]为堆顶最大或最小，a[i]的左子节点为a[2i],右子节点为a[2i+1],父节点为a[i/2]: // a[i] // / \ // a[2i] a[2i+1] // 若取a[0]为堆顶最大或最小，a[i]的左子节点为a[2i+1],右子节点为a[2i+2],父节点为a[(i-1)/2] // a[i] // / \ // a[2i+1] a[2i+2] 而container/heap包采用的是a[0]作为对顶，故左子、右子节点以及父节点表示为a[2i+1]、a[2i+2]、a[(i-1)/2]。</description></item></channel></rss>