<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Hindung's Blog</title><link>https://hindung.cn/tags/leetcode/</link><description>Recent content in LeetCode on Hindung's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 08 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://hindung.cn/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>深拷贝之循环引用</title><link>https://hindung.cn/posts/deep-copy/</link><pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate><guid>https://hindung.cn/posts/deep-copy/</guid><description>题目 实现如下结构体的深拷贝。
type Node struct { Data int Fields []*Node } 即指针指向的内存也需要Copy一份。
解析 观察结构体，由于Fields字段里存放的是指向Node结构体的指针切片，深拷贝时要考虑循环引用的问题，如：
struct a : data: 1 fields: b, c struct b: data: 2 fields: c struct c: data: 3 fields: a // 这里循环引用了a， c-&amp;gt;a-&amp;gt;b, c-&amp;gt;a 可以考虑使用map[*Node]*Node来判断是否有环的情况，即用map[src] = dst来保存拷贝过的节点。
代码 代码如下：
package main import ( &amp;#34;go/ast&amp;#34; &amp;#34;go/token&amp;#34; ) type Node struct { Data int Fields []*Node } // deep copy var M map[*Node]*Node func Dup(src *Node) *Node { if src == nil { return nil } node := &amp;amp;Node{ Data: src.</description></item><item><title>LRU 缓存机制</title><link>https://hindung.cn/posts/lru/</link><pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate><guid>https://hindung.cn/posts/lru/</guid><description>题目 146. LRU 缓存机制
解析 由于要求要用O(1)的时间复杂度，所以要采用双向链表＋map的数据结构解答。
具体源码如下：
package main import &amp;#34;fmt&amp;#34; type LRUCache struct { M map[int]*Node Cap int Size int Head, Tail *Node } type Node struct { Key, Value int Pre, Next *Node } // init LRUCache func Constructor(capacity int) LRUCache { l := LRUCache{ M: map[int]*Node{}, Cap: capacity, Size: 0, Head: &amp;amp;Node{ Key: 0, Value: 0, Pre: nil, Next: nil, }, Tail: &amp;amp;Node{ Key: 0, Value: 0, Pre: nil, Next: nil, }, } // nil&amp;lt;-head&amp;lt;-&amp;gt;tail-&amp;gt; l.</description></item></channel></rss>