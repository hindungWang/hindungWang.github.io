<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithm on Hindung's Blog</title><link>https://hindung.cn/tags/algorithm/</link><description>Recent content in Algorithm on Hindung's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 23 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://hindung.cn/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang实现优先队列</title><link>https://hindung.cn/posts/go-priority-queue/</link><pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate><guid>https://hindung.cn/posts/go-priority-queue/</guid><description>前言 由于刷题时偶尔会用到队列以及优先队列等数据结构，其他语言都有现成的实现，如C++的priority_queue等，使用非常方便，但是由于个人比较喜欢使用golang语言进行答题，但是go对队列以及优先队列的实现只提供了一个接口，即container/heap包中的heap数据结构，故实现还是要自己去码，这里做一个笔记。实现了heap接口来实现priority_queue，并且提供了其他方法的实现。
heap原理 go的container/heap包实现的是数据结构是数组构成的二叉树（完全二叉树），如下所示：
// 树中某个节点的值总是不大于或不小于其孩子节点的值； // 树中每个节点的子树都是堆树 // index 0 1 2 3 4 5 6 7 8 9 // index 1 2 3 4 5 6 7 8 9 10 // a[] = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7} // 4 // / \ // 1 3 // / \ / \ // 2 16 9 10 // /\ / // 14 8 7 // 若取a[1]为堆顶最大或最小，a[i]的左子节点为a[2i],右子节点为a[2i+1],父节点为a[i/2]: // a[i] // / \ // a[2i] a[2i+1] // 若取a[0]为堆顶最大或最小，a[i]的左子节点为a[2i+1],右子节点为a[2i+2],父节点为a[(i-1)/2] // a[i] // / \ // a[2i+1] a[2i+2] 而container/heap包采用的是a[0]作为对顶，故左子、右子节点以及父节点表示为a[2i+1]、a[2i+2]、a[(i-1)/2]。</description></item><item><title>雪花算法</title><link>https://hindung.cn/posts/snowflake/</link><pubDate>Thu, 27 Aug 2020 00:00:00 +0000</pubDate><guid>https://hindung.cn/posts/snowflake/</guid><description>前言 工作项目中有使用到雪花算法(snowflake)，觉得很有意思，所以想深入了解一下实现的原理并做记录。
算法简介 什么是雪花算法 snowflake，雪花。所以snowflake算法就叫做雪花算法。最早是Twitter内部使用的分布式环境唯一ID生成算法。
解决了什么问题 那么，该算法主要解决了：
高并发分布式系统环境下ID不重复 基于时间戳，可以保证有序递增 不依赖第三方库或中间件 生成效率高 算法原理 使用统一不重复系统编号的服务器+毫秒级时间戳+递增序列化生成64bit长整型数字：
+-&amp;gt;1bit not use + 000000000000000000000000000000000000000000000000000000000000000 = 64 bit &amp;lt;--------------------------------------&amp;gt;&amp;lt;---+----&amp;gt;&amp;lt;----------&amp;gt; 41bit millisecond timestamp = 69 years | 12bit Inc num = 4096 v 10bit machine ID= 1024 64bit整数由以下部分组成：
第一位置零，1为负数，故不用； 41位表示毫秒级时间戳； 10位表示机器ID，最多可以部署在1024台服务器上； 12位表示1毫秒的内递增序列，从0开始，到4095； 也就是说同一毫秒内最多能生成4096个id，超出的话需要等待下一毫秒，雪花算法最多冲突等待1ms。
机器ID保证了系统内的机器唯一性，时间戳和递增序列号保证了时序递增。
实现思路 了解了唯一ID的结构之后就可以简单实现雪花算法（伪代码）：
machineID # 机器ID n # 递增序列 now := time().now().Unix() if now == last { # 如果是同1毫秒内 n++ # 自增1 if n &amp;gt; 4095 { # 超过4095，则等待下一毫秒 now = nexttime() n = 0 } } else { n = 0 last = now } ID = now &amp;lt;&amp;lt; 22 | mashineID &amp;lt;&amp;lt; 12 | n # 将结果拼接为64bit之后转换成十进制 深入源代码 雪花生成算法见：snowflake</description></item></channel></rss>