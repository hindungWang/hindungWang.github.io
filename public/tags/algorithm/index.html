<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Algorithm"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://hindung.cn/tags/algorithm/"><title>Algorithm | Hindung Blogs</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.scss integrity crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.babd2f636c40f8c2a90eb07eec05db5d5b170c6461306029c9a468cc2daf879d.js integrity="sha256-ur0vY2xA+MKpDrB+7AXbXVsXDGRhMGApyaRozC2vh50=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=http://hindung.cn/tags/algorithm/index.xml title="Hindung Blogs"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Hindung Blogs</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Algorithm</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav><ul><li class=book-section-flat><strong>Categories</strong><ul></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/go/>Go</a>
<span>12</span></li><li class="flex justify-between"><a href=/tags/kubernetes/>Kubernetes</a>
<span>5</span></li><li class="flex justify-between"><a href=/tags/blog/>Blog</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/makerdown/>Makerdown</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/docker/>Docker</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/network/>Network</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/leetcode/>LeetCode</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/>核心竞争力</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/algorithm/>Algorithm</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/heap/>heap</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/queue/>queue</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gin/>Gin</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/dockerfile/>Dockerfile</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/markdown/>Markdown</a>
<span>1</span></li></ul></li></ul></nav></aside></header><article class="markdown book-post"><h2><a href=/posts/11/>Golang实现优先队列</a></h2><h5>September 23, 2020</h5><div><a href=/tags/queue/>queue</a>,
<a href=/tags/heap/>heap</a>,
<a href=/tags/go/>Go</a>,
<a href=/tags/algorithm/>Algorithm</a></div><p>前言 # 由于刷题时偶尔会用到队列以及优先队列等数据结构，其他语言都有现成的实现，如C++的priority_queue等，使用非常方便，但是由于个人比较喜欢使用golang语言进行答题，但是go对队列以及优先队列的实现只提供了一个接口，即container/heap包中的heap数据结构，故实现还是要自己去码，这里做一个笔记。实现了heap接口来实现priority_queue，并且提供了其他方法的实现。
heap原理 # go的container/heap包实现的是数据结构是数组构成的二叉树（完全二叉树），如下所示：
// 树中某个节点的值总是不大于或不小于其孩子节点的值； // 树中每个节点的子树都是堆树 // index 0 1 2 3 4 5 6 7 8 9 // index 1 2 3 4 5 6 7 8 9 10 // a[] = {4, 1, 3, 2, 16, 9, 10, 14, 8, 7} // 4 // / \ // 1 3 // / \ / \ // 2 16 9 10 // /\ / // 14 8 7 // 若取a[1]为堆顶最大或最小，a[i]的左子节点为a[2i],右子节点为a[2i+1],父节点为a[i/2]: // a[i] // / \ // a[2i] a[2i+1] // 若取a[0]为堆顶最大或最小，a[i]的左子节点为a[2i+1],右子节点为a[2i+2],父节点为a[(i-1)/2] // a[i] // / \ // a[2i+1] a[2i+2] 而container/heap包采用的是a[0]作为对顶，故左子、右子节点以及父节点表示为a[2i+1]、a[2i+2]、a[(i-1)/2]。
<a href=/posts/11/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/6/>雪花算法</a></h2><h5>August 27, 2020</h5><div><a href=/tags/go/>Go</a>,
<a href=/tags/algorithm/>Algorithm</a></div><p>前言 # 工作项目中有使用到雪花算法(snowflake)，觉得很有意思，所以想深入了解一下实现的原理并做记录。
算法简介 # 什么是雪花算法 # snowflake，雪花。所以snowflake算法就叫做雪花算法。最早是Twitter内部使用的分布式环境唯一ID生成算法。
解决了什么问题 # 那么，该算法主要解决了：
高并发分布式系统环境下ID不重复 基于时间戳，可以保证有序递增 不依赖第三方库或中间件 生成效率高 算法原理 # 使用统一不重复系统编号的服务器+毫秒级时间戳+递增序列化生成64bit长整型数字：
+->1bit not use + 000000000000000000000000000000000000000000000000000000000000000 = 64 bit &lt;-------------------------------------->&lt;---+---->&lt;----------> 41bit millisecond timestamp = 69 years | 12bit Inc num = 4096 v 10bit machine ID= 1024 64bit整数由以下部分组成：
第一位置零，1为负数，故不用； 41位表示毫秒级时间戳； 10位表示机器ID，最多可以部署在1024台服务器上； 12位表示1毫秒的内递增序列，从0开始，到4095； 也就是说同一毫秒内最多能生成4096个id，超出的话需要等待下一毫秒，雪花算法最多冲突等待1ms。
机器ID保证了系统内的机器唯一性，时间戳和递增序列号保证了时序递增。
实现思路 # 了解了唯一ID的结构之后就可以简单实现雪花算法（伪代码）：
machineID # 机器ID n # 递增序列 now := time().now().Unix() if now == last { # 如果是同1毫秒内 n++ # 自增1 if n > 4095 { # 超过4095，则等待下一毫秒 now = nexttime() n = 0 } } else { n = 0 last = now } ID = now &lt;&lt; 22 | mashineID &lt;&lt; 12 | n # 将结果拼接为64bit之后转换成十进制 深入源代码 # 雪花生成算法见：snowflake
<a href=/posts/6/>...</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav><ul><li class=book-section-flat><strong>Categories</strong><ul></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/go/>Go</a>
<span>12</span></li><li class="flex justify-between"><a href=/tags/kubernetes/>Kubernetes</a>
<span>5</span></li><li class="flex justify-between"><a href=/tags/blog/>Blog</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/makerdown/>Makerdown</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/docker/>Docker</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/network/>Network</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/leetcode/>LeetCode</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/>核心竞争力</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/algorithm/>Algorithm</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/heap/>heap</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/queue/>queue</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gin/>Gin</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/dockerfile/>Dockerfile</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/markdown/>Markdown</a>
<span>1</span></li></ul></li></ul></nav></div></aside></main></body></html>