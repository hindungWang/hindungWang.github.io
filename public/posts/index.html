<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://hindung.cn/posts/"><title>Posts | Hindung Blogs</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.scss integrity crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.babd2f636c40f8c2a90eb07eec05db5d5b170c6461306029c9a468cc2daf879d.js integrity="sha256-ur0vY2xA+MKpDrB+7AXbXVsXDGRhMGApyaRozC2vh50=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=http://hindung.cn/posts/index.xml title="Hindung Blogs"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Hindung Blogs</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Posts</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav><ul><li class=book-section-flat><strong>Categories</strong><ul></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/go/>Go</a>
<span>12</span></li><li class="flex justify-between"><a href=/tags/kubernetes/>Kubernetes</a>
<span>5</span></li><li class="flex justify-between"><a href=/tags/blog/>Blog</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/makerdown/>Makerdown</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/docker/>Docker</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/network/>Network</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/leetcode/>LeetCode</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/>核心竞争力</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/algorithm/>Algorithm</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/heap/>heap</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/queue/>queue</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gin/>Gin</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/dockerfile/>Dockerfile</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/markdown/>Markdown</a>
<span>1</span></li></ul></li></ul></nav></aside></header><article class="markdown book-post"><h2><a href=/posts/26/>K8s client-go初始化的几种方法</a></h2><h5>July 19, 2022</h5><div><a href=/tags/kubernetes/>Kubernetes</a>,
<a href=/tags/go/>Go</a></div><p>简介 # client-go是k8s的一个基础组件库，是用于与API-Server交互的http客户端。K8s中大部分组件都使用了这个库实现与API-Server的通信功能。除了能够对资源对象的增删改查，还可Watch一个对象、升级成websocket链接等等功能。
client-go支持四种客户端：RESTClient、ClientSet、DynamicClient、DiscoveryClient。这几个client可以相互转换。
RESTClient # RESTClient是最基础的客户端，相当于最底层的基础结构，可以直接通过RESTClient提供的RESTful方法如Get()、Put()、Post()、Delete()进行交互。
一般而言，为了更为优雅的处理，需要进一步封装，通过Clientset封装RESTClient，然后再对外提供接口和服务。
可以通过ClientSet客户端获得：
client := cli.CoreV1().RESTClient().(*rest.RESTClient) ClientSet # Clientset是调用Kubernetes资源对象最常用的client，可以操作所有的资源对象，包含RESTClient。需要制定Group、Version，然后根据Resource获取。
clientset,err := kubernetes.NewForConfig(config) sa, err := clientset.CoreV1().ServiceAccounts("kube-system").Get("kube-shell-admin", metav1.GetOptions{}) DynamicClient # Dynamic client是一种动态的client，它能处理kubernetes所有的资源。不同于clientset，dynamic client返回的对象是一个map[string]interface{}。
dynamicClient,err := dynamic.NewForConfig(config) gvr := schema.GroupVersionResource{Version: "v1",Resource: "pods"} unstructObjList,err := dynamicClient.Resource(gvr).Namespace("dev").List(context.TODO(),metav1.ListOptions{Limit: 100}) DiscoveryClient # DiscoveryClient是发现客户端，主要用于发现kubernetes API Server所支持的资源组、资源版本、资源信息。除此之外，还可以将这些信息存储到本地，用户本地缓存，以减轻对Kubernetes API Server访问的压力。 kubectl的api-versions和api-resources命令输出也是通过DisconversyClient实现的。
discoveryClient,err := discovery.NewDiscoveryClientForConfig(config) APIGroup,APIResourceListSlice,err := discoveryClient.ServerGroupsAndResources() 这几种客户端的初始化都涉及到了入参config，即*rest.Config，这个是用于初始化客户端的所有配置信息。
rest.Config初始化 # 创建client前，需要先从初始化*rest.Config，这个*rest.Config可以从集群外的kubeconfig文件或者集群内部的 tokenFile 和 CAFile初始化（通过ServiceAcount自动挂载）。有以下几种方式：
集群外通过kubeconfig初始化 # BuildConfigFromFlags方法从给定的url或者kubeconfig文件的文件夹路径去初始化config，如果不成功则会使用集群内部方法初始化config，如果不成功则返回一个默认的config。
// "k8s.io/client-go/tools/clientcmd" config, err := clientcmd.
<a href=/posts/26/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/post/>Hello World</a></h2><h5>July 18, 2022</h5><div><a href=/tags/makerdown/>Makerdown</a>,
<a href=/tags/blog/>Blog</a></div><p>欢迎来到hindung的部落格 Copy from @ 马克飞象 # @(示例笔记本)[飞驰|人生|Markdown]
马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：
功能丰富 ：支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手； 得心应手 ：简洁高效的编辑器，提供桌面客户端以及离线Chrome App，支持移动端 Web； 深度整合 ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。 [TOC]
Markdown简介 # Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科
正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注1。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。
代码块 # @requires_authorization def somefunc(param1='', param2=0): '''A docstring''' if param1 > param2: # interesting print 'Greater' return (param2 - param1 + 1) or None class SomeClass: pass >>> message = '''interpreter ... prompt''' LaTeX 公式 # 可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：
<a href=/posts/post/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/20/>容器技术之我见</a></h2><h5>July 23, 2021</h5><div><a href=/tags/docker/>Docker</a></div><p>容器技术 # 什么是容器呢？
印象中第一次接触“容器”这个词，是在化学课上，不就是一装东西的瓶子嘛有啥特别的。
仔细想想，“装”东西即在某种程度上与其他物体隔离开来了。所以称这个「装东西的东西」为容器。
是吧！那现在所说的“容器”到底是啥概念，他能装什么东西，又把什么东西在某种程度上隔离开？
我的理解就是：「把资源隔离开的东西」。
资源泛指OS上的资源，如CPU、内存、设备、文件系统等等。如何进行隔离呢？Linux内核提供了某种机制能让上诉所说的“资源”隔离开来，即Namespace和CGroups。
容器技术就是基于这两个内核特性进行设计和开发。
Namespace # 命名空间在维基百科上的广义解释是：
“在计算机中，命名空间是一组用于标识和引用各种对象的符号（名称）。命名空间可确保所有给定的对象集都具有唯一的名称，以便可以轻松识别它们。”
根据这个定义，Linux内核提供的命名空间定义为：
“命名空间是Linux内核的一项功能，该功能对内核资源进行分区，以使一组进程看到一组资源，而另一组进程看到另一组资源。该功能通过为一组资源和进程具有相同的名称空间而起作用，但是这些名称空间引用了不同的资源。资源可能存在于多个空间中。这样的资源有进程ID、主机名、用户ID、文件名以及一些与网络访问和进程间通信相关。”
从内核版本5.6开始，存在8种名称空间。命名空间功能在所有类型上都是相同的：每个进程都与一个命名空间相关联并且只能查看或使用与该命名空间以及后代命名空间相关联的资源。 这样，每个进程（或其进程组）可以在资源上拥有唯一的视图。隔离哪个资源取决于已为给定进程组创建的名称空间的类型。
Mount (mnt) # 挂载命名空间控制隔离挂载点。即隔离文件系统目录结构。
比如你在每个容器里都有/usr目录，你们都可以访问这个目录，但他们是不一样的。
Process ID (pid) # PID命名空间为进程提供了一套独立于其他命名空间的进程ID（PID）。
PID命名空间是嵌套的，这意味着当一个新的进程被创建时，它将有一个从其当前命名空间到初始PID命名空间的每个命名空间的PID。因此，初始PID命名空间能够看到所有进程，尽管其PID与其他命名空间看到的进程不同。
比如用于创建容器的Runc Daemon进程。
Network (net) # 网络名称空间可虚拟化网络堆栈。由于每个容器有不同的网络接口，每个地址信息，包括IP地址，都可以分开。
Interprocess Communication (ipc) # IPC命名空间将进程与SysV风格的进程间通信隔离。
UTS # UTS（UNIX时间共享）命名空间允许一个系统在不同的进程中出现不同的主机名和域名。
User ID (user) # 用户命名空间是一个提供权限隔离和用户识别隔离的功能，跨越多组进程，从内核3.8开始可用。
在管理员的协助下，有可能建立一个看起来有管理权限的容器，而实际上没有给用户进程提升权限。像PID命名空间一样，用户命名空间是嵌套的，每个新的用户命名空间都被认为是创建它的用户命名空间的子空间。
Control group (cgroup) Namespace # 控制组命名空间，隐藏了进程作为成员的控制组的身份。
在这样的命名空间中的进程，在检查任何进程属于哪个控制组时，会看到一个实际上是相对于创建时设置的控制组的路径，隐藏其真实的控制组位置和身份。
Time Namespace # 时间命名空间允许进程以类似于UTS命名空间的方式看到不同的系统时间。 它在2018年被提出，并在2020年3月发布的Linux 5.6上登陆。
规划中的命名空间 # syslog namespace、Syscalls、Destruction，具体信息请参阅维基百科
CGroup # 控制组cgroups是Linux内核提供的一个功能，用于从硬件和相关方面限制一组特定的分组进程。
如隔离CPU、内存、设备、磁盘io、网络io等。
<a href=/posts/20/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/22/>Iptable规则初探</a></h2><h5>June 1, 2021</h5><div><a href=/tags/kubernetes/>Kubernetes</a>,
<a href=/tags/network/>Network</a></div><p>iptable是啥 # 参考维基百科：iptables是运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的处理和转发。
iptables规则 # iptables主要有raw、mangle、filter、nat这几个表，对应几个规则：PREROUTING 、INPUT 、FORWARD 、OUTPUT、POSTROUTING 。
NAT 包括 SNAT （源地址转换）和 DNAT （目的地址转换）。两者的区别在于做地址转换是在路由前还是路由后，SNAT和DNAT总是成对出现的。
对应的含义可以简单理解为：
表名 用途 包含的规则 表名 用途 包含的规则 raw 关闭nat表上启用的连接追踪机制 PREROUTING，OUTPUT mangle 拆解报文，做出修改，并重新封装的功能 PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING nat 网络地址转换功能 PREROUTING，OUTPUT，POSTROUTING（centos7中还有INPUT，centos6中没有） filter 负责过滤功能，防火墙 INPUT，FORWARD，OUTPUT 规则的意义：
规则 意义 PREROUTING 报文刚刚到达主机，还没经过路由 INPUT 报文已经经过路由，判断是发送给本机的报文 FORWARD 报文已经经过路由，判断不是本机的报文，如果内核开启转发功能则转发出去，否则丢弃 OUTPUT 报文从应用发出报文已经经过路由 POSTROUTING 报文从应用发出已经经过路由，准备从网卡发出 数据从网络到达主机，再从主机到达应用的过程，以集群中traefik部署的Ingress为例，可以理解为： iptable相关命令 # 查看iptables规则：
iptables -L, --list [chain] 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则 参考https://wangchujiang.com/linux-command/c/iptables.html</p></article><article class="markdown book-post"><h2><a href=/posts/25/>K8s之calico网络插件东西南北流量</a></h2><h5>June 1, 2021</h5><div><a href=/tags/kubernetes/>Kubernetes</a>,
<a href=/tags/network/>Network</a></div><p>前言 # 环境采用了calico＋ebgp/ibgp＋交换机组成了一个扁平化网络，使用calico宣告POD IP，做到了POD与其他虚拟机和开发网落处在同一个平面的效果。
具体组网信息可以参考calico网站。
东西流量 # Pod到Service流量 # 一般的应用大多数是以Pod到Service的形式去请求服务，从而出现东西方向的流量，目前集群的网络采用Calico作为网络插件，POD的IP由Calico进行统一分配，Service IP由集群K8s分配，并且配合Kube-proxy操作Iptable创建对应的规则。
首先，创建一个POD时，calico会同时在POD对应的主机生成对应的calico网桥calixxx，并且分配IP，并且通过calico组件路由宣告出去：
发送到calixxx的流量会转发至POD的eth0网卡，而从POD发出来的报文则是通过ARP 代理的方式转发至calixxx网桥。
而当一个Service创建之后，会根据选择器与POD标签配对，对应上POD IP并且被Kube-Proxy监控到，K8s会随即生成对应的DNS记录service.namespace.local.cluster:serviceclusterIP，然后在Iptables添加相应的规则记录，如(10.88.145.173为ServiceIP，10.90.1.127为POD IP)：
一般的，在集群中从POD访问Service，再从Service到达对应的POD流程为（正向请求用①表示，回复报文用(1)表示）：
下面梳理一下请求的主要过程：
①POD向domian发送请求 ②由于没有IP，POD先向CoreDNS查询域名对应的IP地址 ③CoreDNS返回对应的Service IP ④POD拿到IP之后，向该IP发送数据，对应的报文从calixxx网桥出来 ⑤从calixxx网桥出来后，进入Host Iptables链，进入IP tables之后，进入对应的链路如上图规则，最后得到Service对应的POD IP，并转发到此IP，此时会经过路由，分为两种情况，目标IP在同一节点上（路由表有记录）或者不在同一节点上（路由表无记录） ⑥如果在同一节点上，根据路由表则会路由到目标IP对应的calixxx网桥 ⑦如果不在同一节点上，则根据路由表规则，会从bond1口出去 ⑧到达交换机，交换机有对应的路由条目，则会走到（3）和（4）过程进入Host，并且走到Iptables，通过路由，转到⑥过程 ⑨到达calixxx网桥之后会转发至POD eth0网卡，到达POD 应答过程：
(1)POD以传过来的源POD IP作为目的IP从eth0发出，通过ARP代理转发到calixxx网桥 (2)达到calixxx网桥之后会经过POD所在的节点的Host路由表，同样分为两种情况 (3)如果不在同一节点上，则会走bond1到交换机 (4)再从交换机到达对应的节点，之后便到达过程（5） (5)经过路由表，到达目的IP 对应calixxx网桥 (6)再从网桥到达POD eth0 Pod到Pod流量 # 由于网络平面化，POD IP可以直通，所以会存在POD相互访问的场景，如隐私号应用等：
主要过程：
①POD以目标POD的IP作为目的IP，从eth0发出，到达calixxx ②到达calixxx网桥之后会进入Host内核Iptables链到达PREROUTING（路由前） ③之后进入路由模块进行路由，路由判断该报文是否是发给本机的，如果是则往上收将进入INPUT链，此过程不在讨论范围，由于报文目的地址是POD IP，所以会转发出去 ④到达FORWARD链后进入POSTROUTING（路由后） ⑤进入POSTROUTING会进行一些地址转换等操作后发往对应网卡或者网桥，如果路由结果表明该报文要通过网卡Bond1出去则会走到⑧过程，否则会走到⑥ ⑥表明目的IP在本机网桥上（即POD在同一节点上），则进入目的地址对应的calixxx网桥 ⑦再转发至POD eth0网卡到达目的地 ⑧报文从内核出来进入网卡，准备向外发出 ⑨到达交换机，由于交换机有所有POD的路由信息，所以他能正确处理经过的报文 ⑩经过路由后到达POD所在节点的入口网卡Bond1 11.到达网卡之后会进入内核Linux协议栈进行Iptables规则链匹配（可能的路径为到③->④->⑤->⑥->⑦到达对应的POD） 回复过程：
(1)到达目的POD之后，应用根据源IP进行回应，转发至calixxx网桥 (2)到达网桥之后进入Linux协议栈，其过程会从③->④->⑤->（3）到达源POD (3)到达源POD对应的网桥 (4)从网桥转发至POD eth0网卡，此时会经过Linux协议栈，最终报文从内核到用户空间送到应用。 南北流量 # 外部流量从Ingress(越过service)到Pod # client客户端请求POD应用，首先要创建对应的Service，并且创建Ingress路由。集群中采用Traefik作为Ingres Controller，以DeamonSet的方式部署，并且开启hostNetwork模式，与主机公用网络协议栈。并且接管所有到达主机的80端口、8080端口的报文。Traefik的原理主要是通过监控APIserver来监控Service、POD的变化，并维护路由，而且接管80端口的流量，转发到对应路由的POD IP上。
<a href=/posts/25/>...</a></p></article><ul class="pagination pagination-default"><li class="page-item disabled"><a aria-disabled=true aria-label=First class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;&#171;</span></a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Previous class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;</span></a></li><li class="page-item active"><a aria-current=page aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/posts/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/posts/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/posts/page/4/ aria-label="Page 4" class=page-link role=button>4</a></li><li class=page-item><a href=/posts/page/5/ aria-label="Page 5" class=page-link role=button>5</a></li><li class=page-item><a href=/posts/page/2/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/5/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav><ul><li class=book-section-flat><strong>Categories</strong><ul></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/go/>Go</a>
<span>12</span></li><li class="flex justify-between"><a href=/tags/kubernetes/>Kubernetes</a>
<span>5</span></li><li class="flex justify-between"><a href=/tags/blog/>Blog</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/makerdown/>Makerdown</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/docker/>Docker</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/network/>Network</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/leetcode/>LeetCode</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/>核心竞争力</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/algorithm/>Algorithm</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/heap/>heap</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/queue/>queue</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gin/>Gin</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/dockerfile/>Dockerfile</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/markdown/>Markdown</a>
<span>1</span></li></ul></li></ul></nav></div></aside></main></body></html>