<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Golang基本类型"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Golang语言模型"><meta property="og:description" content="Golang基本类型"><meta property="og:type" content="article"><meta property="og:url" content="http://hindung.cn/posts/4/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-07-26T00:00:00+00:00"><meta property="article:modified_time" content="2020-07-26T00:00:00+00:00"><title>Golang语言模型 | Hindung Blogs</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.scss integrity crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.babd2f636c40f8c2a90eb07eec05db5d5b170c6461306029c9a468cc2daf879d.js integrity="sha256-ur0vY2xA+MKpDrB+7AXbXVsXDGRhMGApyaRozC2vh50=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Hindung Blogs</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Golang语言模型</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#前言>前言</a><ul><li><a href=#基本类型的内存模型>基本类型的内存模型</a></li><li><a href=#数组和切片>数组和切片</a></li></ul></li><li><a href=#map的实现>map的实现</a></li><li><a href=#struct结构体>struct结构体</a><ul><li><a href=#struct的字节对齐>struct的字节对齐</a></li></ul></li><li><a href=#make和new>make和new</a></li><li><a href=#总结>总结</a></li></ul></nav></aside></header><article class=markdown><h1><a href=/posts/4/>Golang语言模型</a></h1><h5>July 26, 2020</h5><div><a href=/tags/go/>Go</a></div><h2 id=前言>前言
<a class=anchor href=#%e5%89%8d%e8%a8%80>#</a></h2><p>这篇笔记主要记录一下学习Go见到的各种数据类型，从数据类型在内存的分布上看了解其中的原理，主要包括：</p><ul><li>基本类型（int, string, uint, int8, int16, byte, rune, unitptr, float32, float64, complex64, complex128, bool等）</li><li>数组和slice的内存模型（string是特殊的slice）</li><li>指针的内存模型及unitptr与unsafe.Pointer、普通指针 *T的区别</li><li>map的内存模型</li><li>struct的内存模型和字节对齐</li><li>channel、goroutine的内存模型以后单独记录</li><li>interface的内存模型已经在第一篇笔记里</li></ul><p>Go的内存模型与C语言很像，所以了解C语言应该很容易理解Go的内存模型。</p><h3 id=基本类型的内存模型>基本类型的内存模型
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b>#</a></h3><p>Go语言有18种基本的数据结构：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>bool</span>    <span style=color:#66d9ef>string</span>  <span style=color:#66d9ef>rune</span>      <span style=color:#66d9ef>byte</span>        <span style=color:#66d9ef>int</span>         <span style=color:#66d9ef>uint</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int8</span>    <span style=color:#66d9ef>uint8</span>   <span style=color:#66d9ef>int16</span>     <span style=color:#66d9ef>uint16</span>      <span style=color:#66d9ef>int32</span>       <span style=color:#66d9ef>uint32</span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>int64</span>   <span style=color:#66d9ef>uint64</span>  <span style=color:#66d9ef>float32</span>   <span style=color:#66d9ef>float64</span>     <span style=color:#66d9ef>complex64</span>   <span style=color:#66d9ef>complex128</span>
</span></span></code></pre></div><p>其中string和bool类型比较特殊，这个后面讨论。</p><p>然后 byte 类型是uint8的别名，rune是int32的别名。</p><p>平台相关的数据类型有：</p><ul><li>uint：int32 或者是 int64，看机子类型</li><li>uintptr：足够表示指针大小的无符号整数类型</li></ul><p>这些基本类型在内存中的表示如：</p><p><img src=https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gaddk6zal0j205g02n0q0.jpg alt=1577585835.jpg></p><h3 id=数组和切片>数组和切片
<a class=anchor href=#%e6%95%b0%e7%bb%84%e5%92%8c%e5%88%87%e7%89%87>#</a></h3><h4 id=数组>数组
<a class=anchor href=#%e6%95%b0%e7%bb%84>#</a></h4><p>对于数组来说，如：<code>var arr = [5]byte{1,2,3,4,5}</code></p><p><img src=https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gaddpwa2bvj208x02rwe9.jpg alt=1577586159(https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gaddpwa2bvj208x02rwe9.jpg).jpg></p><p>对于arr这个[5]byte类型，他的内存就是5个连续的字节, 一个数组的定义同时包括了长度和类型。
比如：<code>var a [4]int</code>，那么就表示声明了一个类型是数组，元素类型是int，长度是4。这里需要注意的是Go语言的数组和C语言的不一样，C语言的数组是一个指针，指向数组的一个元素。但是在Go语言里面数组就是一个普通的值类型。而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化。</p><p>所以[4]int和[5]int表示两种完全不同的类型。</p><h4 id=切片>切片
<a class=anchor href=#%e5%88%87%e7%89%87>#</a></h4><p>在之前的一些<a href=https://mangoqiqi.github.io/2018/09/09/golang/>golang基础</a>里已经有一些切片类型的简单使用方法了，这里就来探究一下切片的底层数据结构和实现。</p><p>切片是对数组中一段数据的引用。在内存中它有三段数据组成：一个指向数据头的指针、切片的长度、切片的容量。长度是索引操作的上界，如：x[i] 。容量是切片操作的上界，如：x[i:j]。</p><p>比如我通过s := make([]byte, 5)当容量参数被忽略时，它默认为指定的长度，创建的切片内存如下：</p><p><img src=https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadealbq7nj208d02t741.jpg alt=1577587354(https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadealbq7nj208d02t741.jpg).jpg></p><p>如果我们通过修改切片引用的数据区域和大小，s = s[2:4], 那么就变成了如下的结构</p><p><img src=https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadee0257zj207x03pjr5.jpg alt=1577587559(https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadee0257zj207x03pjr5.jpg).jpg></p><p>我们通过下面的代码可以很快弄清楚slice的内存模型</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sliceA</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>5</span>]<span style=color:#66d9ef>byte</span>{<span style=color:#ae81ff>0</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>[:]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>sliceA</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> = <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> = <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>sliceA</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>输出结果如下</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0xc042038448</span>
</span></span><span style=display:flex><span>{<span style=color:#ae81ff>0xc042038448</span> <span style=color:#ae81ff>5</span> <span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span>{<span style=color:#ae81ff>0xc04203844a</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>}
</span></span></code></pre></div><p>0xc04203844a - 0xc042038448 = 2， 刚好是偏移了两个byte。</p><p>从上面的内存模型来看，如果两个数组相互赋值，那么将会触发数组全量拷贝的动作，但是如果是传递切片，那么将只需要永远申请固定大小的切片对象就可以了，底层的数组通过引用传递。</p><h4 id=切片的内存增长>切片的内存增长
<a class=anchor href=#%e5%88%87%e7%89%87%e7%9a%84%e5%86%85%e5%ad%98%e5%a2%9e%e9%95%bf>#</a></h4><p>从内存模型来看，切片就是引用了一个固定的数组， 一个切片的容量受到起始索引和底层数组容量的限制。Go语言提供了内置的copy和append函数来增长切片的容量，那么调用这些函数以后切片的内存会发生什么变化呢？</p><p>copy和append这两个是内置函数，是看不到go源码实现，可能使用C/C++/汇编实现的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> copy(<span style=color:#a6e22e>dst</span>, <span style=color:#a6e22e>src</span> []<span style=color:#a6e22e>Type</span>) <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> append(<span style=color:#a6e22e>slice</span> []<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>elems</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>Type</span>) []<span style=color:#a6e22e>Type</span>
</span></span></code></pre></div><p><em>copy方法</em></p><p>copy方法并不会修改slice的内存模型，仅仅是将某个slice的内容拷贝到另外一个slice中去。底层的实现在runtime\slice.go中，这个方法比较简单，就不赘述了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>slicecopy</span>(<span style=color:#a6e22e>to</span>, <span style=color:#a6e22e>fm</span> <span style=color:#a6e22e>slice</span>, <span style=color:#a6e22e>width</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><p><em>append方法</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sliceA</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>sliceA</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a == []int{0}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>a</span> = append(<span style=color:#a6e22e>a</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// a == []int{0, 1, 2, 3}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ptr</span> = <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>sliceA</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>a</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>输出结果是</span><span style=color:#960050;background-color:#1e0010>：</span>
</span></span><span style=display:flex><span>{<span style=color:#ae81ff>0xc04203a448</span> <span style=color:#ae81ff>1</span> <span style=color:#ae81ff>1</span>}
</span></span><span style=display:flex><span>{<span style=color:#ae81ff>0xc0420369e0</span> <span style=color:#ae81ff>4</span> <span style=color:#ae81ff>4</span>}
</span></span></code></pre></div><p>那么从上面可以看出，append方法其实重新生成了一个新的数组，然后返回的切片引用了这个新的数组，那我们来重点看一下append方法的实现，为了简单点，写出下面的代码，然后生成汇编：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>byte</span>{<span style=color:#e6db74>&#39;a&#39;</span>}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> = append(<span style=color:#a6e22e>b</span>, <span style=color:#e6db74>&#39;b&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>b</span>), cap(<span style=color:#a6e22e>b</span>))  <span style=color:#75715e>// output : ab 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>从下面的汇编可以得到两个信息：
runtime.growslice是用来实现slice增长的函数
cap函数的实现仅仅是调用b.cap这个成员</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>main</span> <span style=color:#a6e22e>STEXT</span> <span style=color:#a6e22e>size</span>=<span style=color:#ae81ff>348</span> <span style=color:#a6e22e>args</span>=<span style=color:#ae81ff>0x0</span> <span style=color:#a6e22e>locals</span>=<span style=color:#ae81ff>0x80</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0036</span> <span style=color:#ae81ff>00054</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>LEAQ</span>	<span style=color:#66d9ef>type</span>.uint8(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x003d</span> <span style=color:#ae81ff>00061</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x003d</span> <span style=color:#ae81ff>00061</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, (<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0041</span> <span style=color:#ae81ff>00065</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0041</span> <span style=color:#ae81ff>00065</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>LEAQ</span>	<span style=color:#e6db74>&#34;&#34;</span>..<span style=color:#a6e22e>autotmp_9</span><span style=color:#f92672>+</span><span style=color:#ae81ff>71</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0046</span> <span style=color:#ae81ff>00070</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0046</span> <span style=color:#ae81ff>00070</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x004b</span> <span style=color:#ae81ff>00075</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0054</span> <span style=color:#ae81ff>000</span><span style=color:#ae81ff>84</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x005d</span> <span style=color:#ae81ff>000</span><span style=color:#ae81ff>93</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0066</span> <span style=color:#ae81ff>00102</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>growslice</span>(<span style=color:#a6e22e>SB</span>)  <span style=color:#75715e>// 实现slice增长
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#ae81ff>0x006b</span> <span style=color:#ae81ff>00107</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x006b</span> <span style=color:#ae81ff>00107</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#ae81ff>40</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0070</span> <span style=color:#ae81ff>00112</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#ae81ff>48</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>CX</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0075</span> <span style=color:#ae81ff>00117</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#ae81ff>56</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>DX</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x007a</span> <span style=color:#ae81ff>00122</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>DX</span>, <span style=color:#e6db74>&#34;&#34;</span>.<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>cap</span><span style=color:#f92672>+</span><span style=color:#ae81ff>72</span>(<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x007f</span> <span style=color:#ae81ff>00127</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>MOVB</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>98</span>, <span style=color:#ae81ff>1</span>(<span style=color:#a6e22e>AX</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0083</span> <span style=color:#ae81ff>00131</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, (<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x008b</span> <span style=color:#ae81ff>0013</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x008b</span> <span style=color:#ae81ff>0013</span><span style=color:#ae81ff>9</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0090</span> <span style=color:#ae81ff>00144</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)	<span style=color:#a6e22e>LEAQ</span>	<span style=color:#ae81ff>1</span>(<span style=color:#a6e22e>CX</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0094</span> <span style=color:#ae81ff>0014</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x0099</span> <span style=color:#ae81ff>00153</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>DX</span>, <span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x009e</span> <span style=color:#ae81ff>0015</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>slicebytetostring</span>(<span style=color:#a6e22e>SB</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x00a3</span> <span style=color:#ae81ff>00163</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#ae81ff>40</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x00a8</span> <span style=color:#ae81ff>0016</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x00a8</span> <span style=color:#ae81ff>0016</span><span style=color:#ae81ff>8</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>CX</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x00ad</span> <span style=color:#ae81ff>00173</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>PCDATA</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x00ad</span> <span style=color:#ae81ff>00173</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>CX</span>, (<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x00b1</span> <span style=color:#ae81ff>00177</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>)
</span></span><span style=display:flex><span>	<span style=color:#ae81ff>0x00b6</span> <span style=color:#ae81ff>001</span><span style=color:#ae81ff>82</span> (<span style=color:#a6e22e>goslice</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>10</span>)	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>convTstring</span>(<span style=color:#a6e22e>SB</span>)
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>growslice的实现：src\runtime\slice.go</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>growslice</span>(<span style=color:#a6e22e>et</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>old</span> <span style=color:#a6e22e>slice</span>, <span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>slice</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>cap</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>doublecap</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>newcap</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cap</span> &gt; <span style=color:#a6e22e>doublecap</span> {                 <span style=color:#75715e>// 如果新的大小是当前大小2倍以上，则大小增长为新大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>cap</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span> &lt; <span style=color:#ae81ff>1024</span> {              <span style=color:#75715e>// 如果当前大小小于1024，按每次2倍增长
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>newcap</span> = <span style=color:#a6e22e>doublecap</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {                         <span style=color:#75715e>// 否则每次按当前大小1/4增长，直到增长的大小超过或等于新大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>newcap</span> &lt; <span style=color:#a6e22e>cap</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>newcap</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f92672>......</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>p</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>kind</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>kindNoPointers</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>capmem</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, <span style=color:#a6e22e>lenmem</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Only clear the part that will not be overwritten.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>memclrNoHeapPointers</span>(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>newlenmem</span>), <span style=color:#a6e22e>capmem</span><span style=color:#f92672>-</span><span style=color:#a6e22e>newlenmem</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Note: can&#39;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>capmem</span>, <span style=color:#a6e22e>et</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>writeBarrier</span>.<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>memmove</span>(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, <span style=color:#a6e22e>lenmem</span>)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>lenmem</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>et</span>, <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>i</span>), <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>array</span>, <span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>slice</span>{<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>old</span>.<span style=color:#a6e22e>len</span>, <span style=color:#a6e22e>newcap</span>}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>具体实现的代码就不说了，其实就是判断cap，生成一个新的数组，将old的元素拷贝到新的slice中去。
扩容规则上面的代码已经说明了：</p><p>如果新的大小是当前大小2倍以上，则大小增长为新大小，
否则循环以下操作：如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。</p><p>在runtime\slice.go中，我们可以看到</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>slice</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>array</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>len</span>   <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cap</span>   <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个也是Go语言内部的slice数据结构，和我们前面定义的是一致的，slice的make，copy，grow等函数都在这个文件中实现</p><p><em>字符串</em></p><p>字符串在内存中其实表示成了这么一个数据结构
这个定义是在runtime\string.go中定义的</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>stringStruct</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>str</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;hello&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>stringStruct</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>s</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>[:<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> = <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>stringStruct</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>t</span> = <span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>2</span>:<span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> = <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>stringStruct</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>t</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)
</span></span></code></pre></div><p>从上面的代码可以输出如下的结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span>{<span style=color:#ae81ff>0x4b1cbe</span> <span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span>{<span style=color:#ae81ff>0x4b1cbe</span> <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>{<span style=color:#ae81ff>0x4b1cc0</span> <span style=color:#ae81ff>1</span>}
</span></span></code></pre></div><p>所以说，字符串也是一种特殊的切片，但是是没有容量，只有长度属性。</p><h2 id=map的实现>map的实现
<a class=anchor href=#map%e7%9a%84%e5%ae%9e%e7%8e%b0>#</a></h2><p>Go语言的map并不是像C++的map一样用二叉树实现的，而是典型Hash实现的。</p><p>定义一个map：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>Map</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>        <span style=color:#75715e>// 只是定义，没有分配空间，不能使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Map</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)    <span style=color:#75715e>// 分配空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>cMap</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)  <span style=color:#75715e>// 也可以这样
</span></span></span></code></pre></div><p>在src\runtime\map.go里面可以找到具体的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>count</span>     <span style=color:#66d9ef>int</span>              <span style=color:#75715e>// count 用于记录当前哈希表元素数量，这个字段让我们不再需要去遍历整个哈希表来获取长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>flags</span>     <span style=color:#66d9ef>uint8</span>            <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>B</span>         <span style=color:#66d9ef>uint8</span>            <span style=color:#75715e>// 表示了当前哈希表持有的 buckets 数量，但是因为哈希表的扩容是以 2 倍数进行的，所以这里会使用对数来存储，我们可以简单理解成 len(buckets) == 2^B
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span>           <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>hash0</span>     <span style=color:#66d9ef>uint32</span>           <span style=color:#75715e>// 哈希种子，这个值会在调用哈希函数的时候作为参数传进去，它的主要作用就是为哈希函数的结果引入一定的随机性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buckets</span>    <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>oldbuckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>  <span style=color:#75715e>// 哈希在扩容时用于保存之前 buckets 的字段，它的大小都是当前 buckets 的一半；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nevacuate</span>  <span style=color:#66d9ef>uintptr</span>         <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>extra</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mapextra</span>            <span style=color:#75715e>// 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>go语言的map其实就是一个bucket的数组，这个数组的大小永远是2的次幂。
具体的实现可以在这里看到：<a href=https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/>https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</a></p><h2 id=struct结构体>struct结构体
<a class=anchor href=#struct%e7%bb%93%e6%9e%84%e4%bd%93>#</a></h2><p>Go语言里面的结构体内存模型和C语言里面一样的，都是连续的内存，如果是指针，那么就通过指针跳转</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-GO data-lang=GO><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Point</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>X</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Y</span> <span style=color:#66d9ef>int</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那么内存模型就是：</p><p><img src=https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadflnr12fj203t039dfl.jpg alt=1577590070(https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadflnr12fj203t039dfl.jpg).jpg></p><h3 id=struct的字节对齐>struct的字节对齐
<a class=anchor href=#struct%e7%9a%84%e5%ad%97%e8%8a%82%e5%af%b9%e9%bd%90>#</a></h3><p>在64位系统上面，Go语言的字节是8直接对齐，如果不足的，就补充padding。
这里有详细的描述：<a href=http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/>http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/</a></p><p>下面有一个简单的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Example</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>BoolValue</span> <span style=color:#66d9ef>bool</span>          <span style=color:#75715e>// 1 byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>IntValue</span> <span style=color:#66d9ef>int16</span>          <span style=color:#75715e>// 2 byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>FloatValue</span> <span style=color:#66d9ef>float32</span>      <span style=color:#75715e>// 4 byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>example</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Example</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>BoolValue</span>:  <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>IntValue</span>:   <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>FloatValue</span>: <span style=color:#ae81ff>3.141592</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>alignmentBoundary</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Alignof</span>(<span style=color:#a6e22e>example</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sizeBool</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>BoolValue</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>offsetBool</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>BoolValue</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sizeInt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>IntValue</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>offsetInt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>IntValue</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sizeFloat</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>FloatValue</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>offsetFloat</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>FloatValue</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;size Example: %d\n&#34;</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>example</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Alignment Boundary: %d\n&#34;</span>, <span style=color:#a6e22e>alignmentBoundary</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;BoolValue = Size: %d Offset: %d Addr: %v\n&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sizeBool</span>, <span style=color:#a6e22e>offsetBool</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>BoolValue</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;IntValue = Size: %d Offset: %d Addr: %v\n&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sizeInt</span>, <span style=color:#a6e22e>offsetInt</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>IntValue</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;FloatValue = Size: %d Offset: %d Addr: %v\n&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sizeFloat</span>, <span style=color:#a6e22e>offsetFloat</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>example</span>.<span style=color:#a6e22e>FloatValue</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出结果如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>size</span> <span style=color:#a6e22e>Example</span>: <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>Alignment</span> <span style=color:#a6e22e>Boundary</span>: <span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>BoolValue</span> = <span style=color:#a6e22e>Size</span>: <span style=color:#ae81ff>1</span> <span style=color:#a6e22e>Offset</span>: <span style=color:#ae81ff>0</span> <span style=color:#a6e22e>Addr</span>: <span style=color:#ae81ff>0xc04200a230</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>IntValue</span> = <span style=color:#a6e22e>Size</span>: <span style=color:#ae81ff>2</span> <span style=color:#a6e22e>Offset</span>: <span style=color:#ae81ff>2</span> <span style=color:#a6e22e>Addr</span>: <span style=color:#ae81ff>0xc04200a232</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>FloatValue</span> = <span style=color:#a6e22e>Size</span>: <span style=color:#ae81ff>4</span> <span style=color:#a6e22e>Offset</span>: <span style=color:#ae81ff>4</span> <span style=color:#a6e22e>Addr</span>: <span style=color:#ae81ff>0xc04200a234</span>
</span></span></code></pre></div><p>可以看出在64位机器是按照8字节对齐的，并且bool的后面增加了一个字节的padding</p><h2 id=make和new>make和new
<a class=anchor href=#make%e5%92%8cnew>#</a></h2><p>在Go语言里面有两种方式来创建数据结构：new和make</p><p>切片、map和通道，使用make，
数组、结构体和所有的值类型，使用new，
因为new仅仅是分配内存，但是make还包括了初始化，
因为slice，map和channel在底层实现的时候并不是一个简单的值，而是一个数据结构，并且这个数据结构中要初始化以后才能使用。并且make不是返回指针，而是返回一个<em>类型</em>。</p><p>对于切片，使用new和make的区别：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>sliceA</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>len</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> new([]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>sliceA</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>p</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>q</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span> = <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>sliceA</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>q</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>ptr</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ouput:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{&lt;<span style=color:#66d9ef>nil</span>&gt; <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>}
</span></span><span style=display:flex><span>{<span style=color:#ae81ff>0x5811b0</span> <span style=color:#ae81ff>0</span> <span style=color:#ae81ff>0</span>}
</span></span></code></pre></div><p>我们来看一下slice的make做了啥：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeslice</span>(<span style=color:#a6e22e>et</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>len</span>, <span style=color:#a6e22e>cap</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>cap</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>len</span> &lt; <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>len</span> &gt; <span style=color:#a6e22e>cap</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// NOTE: Produce a &#39;len out of range&#39; error instead of a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// &#39;cap out of range&#39; error when someone does make([]T, bignumber).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// &#39;cap out of range&#39; is true too, but since the cap is only being
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// supplied implicitly, saying len is clearer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// See golang.org/issue/4085.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(<span style=color:#a6e22e>et</span>.<span style=color:#a6e22e>size</span>, uintptr(<span style=color:#a6e22e>len</span>))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>len</span> &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>panicmakeslicelen</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>panicmakeslicecap</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>et</span>, <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从上面来看，最重要就是通过mallocgc来申请了一个数组。</p><p>通过查看汇编代码就可以看出make底层是调用哪个函数了:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makemap</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>hint</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(uintptr(<span style=color:#a6e22e>hint</span>), <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>hint</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// initialize Hmap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span> = new(<span style=color:#a6e22e>hmap</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span> = <span style=color:#a6e22e>fastrand</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Find the size parameter B which will hold the requested # of elements.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>B</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>hint</span>, <span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>B</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> = <span style=color:#a6e22e>B</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// allocate initial hash table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// if B == 0, the buckets field is allocated lazily later (in mapassign)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// If hint is large zeroing this memory could take a while.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> = new(<span style=color:#a6e22e>mapextra</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>h</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从上面看，map初始化最重要的就是创建buckets。</p><h2 id=总结>总结
<a class=anchor href=#%e6%80%bb%e7%bb%93>#</a></h2><p>整体来说，Go语言的对象内存模型比C++要简单的多并且与C很像，毕竟没有继承，虚函数，多重继承等等，了解这些内存模型，对于平时使用这些类型时可以少踩坑是有帮助的。</p><p><em><strong>参考链接：</strong></em></p><p><a href=https://skyao.io/learning-go/grammar/type/basic.html>https://skyao.io/learning-go/grammar/type/basic.html</a></p><p><a href=https://studygolang.com/articles/9169>https://studygolang.com/articles/9169</a></p><p><a href=https://juejin.im/post/5ceffeddf265da1bc8540df5>使用map实现set</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#前言>前言</a><ul><li><a href=#基本类型的内存模型>基本类型的内存模型</a></li><li><a href=#数组和切片>数组和切片</a></li></ul></li><li><a href=#map的实现>map的实现</a></li><li><a href=#struct结构体>struct结构体</a><ul><li><a href=#struct的字节对齐>struct的字节对齐</a></li></ul></li><li><a href=#make和new>make和new</a></li><li><a href=#总结>总结</a></li></ul></nav></div></aside></main></body></html>