<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Golang语言模型 :: Hindung Blogs</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Golang基本类型" />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<link rel="canonical" href="http://hindung.cn/posts/4/" />




<link rel="stylesheet" href="http://hindung.cn/assets/style.css">

  <link rel="stylesheet" href="http://hindung.cn/assets/green.css">






<link rel="apple-touch-icon" href="http://hindung.cn/img/apple-touch-icon-192x192.png">

  <link rel="shortcut icon" href="http://hindung.cn/img/favicon/green.png">



<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Golang语言模型">
<meta property="og:description" content="Golang基本类型" />
<meta property="og:url" content="http://hindung.cn/posts/4/" />
<meta property="og:site_name" content="Hindung Blogs" />

  
    <meta property="og:image" content="http://hindung.cn/img/favicon/green.png">
  

<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">


  <meta property="article:published_time" content="2020-07-26 00:00:00 &#43;0000 UTC" />












</head>
<body class="green">


<div class="container center headings--one-size">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Hindung
  </div>
</a>

    </div>
    
      <div class="menu-trigger">menu</div>
    
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
        
          <li><a href="/posts">Post</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
      
        <li><a href="/posts">Post</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="http://hindung.cn/posts/4/">Golang语言模型</a></h1>
  <div class="post-meta">
    
      <span class="post-date">
        2020-07-26
        
      </span>
    
    
    
      <span class="post-reading-time">:: 6 min read (1149 words)</span>
    
  </div>

  
  <span class="post-tags">
    
    #<a href="http://hindung.cn/tags/go/">Go</a>&nbsp;
    
  </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        Table of Contents
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#前言">前言</a>
      <ul>
        <li><a href="#基本类型的内存模型">基本类型的内存模型</a></li>
        <li><a href="#数组和切片">数组和切片</a></li>
      </ul>
    </li>
    <li><a href="#map的实现">map的实现</a></li>
    <li><a href="#struct结构体">struct结构体</a>
      <ul>
        <li><a href="#struct的字节对齐">struct的字节对齐</a></li>
      </ul>
    </li>
    <li><a href="#make和new">make和new</a></li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <h2 id="前言">前言<a href="#前言" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>这篇笔记主要记录一下学习Go见到的各种数据类型，从数据类型在内存的分布上看了解其中的原理，主要包括：</p>
<ul>
<li>基本类型（int, string, uint, int8, int16, byte, rune, unitptr, float32, float64, complex64, complex128, bool等）</li>
<li>数组和slice的内存模型（string是特殊的slice）</li>
<li>指针的内存模型及unitptr与unsafe.Pointer、普通指针 *T的区别</li>
<li>map的内存模型</li>
<li>struct的内存模型和字节对齐</li>
<li>channel、goroutine的内存模型以后单独记录</li>
<li>interface的内存模型已经在第一篇笔记里</li>
</ul>
<p>Go的内存模型与C语言很像，所以了解C语言应该很容易理解Go的内存模型。</p>
<h3 id="基本类型的内存模型">基本类型的内存模型<a href="#基本类型的内存模型" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>Go语言有18种基本的数据结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span>    <span style="color:#66d9ef">string</span>  <span style="color:#66d9ef">rune</span>      <span style="color:#66d9ef">byte</span>        <span style="color:#66d9ef">int</span>         <span style="color:#66d9ef">uint</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int8</span>    <span style="color:#66d9ef">uint8</span>   <span style="color:#66d9ef">int16</span>     <span style="color:#66d9ef">uint16</span>      <span style="color:#66d9ef">int32</span>       <span style="color:#66d9ef">uint32</span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int64</span>   <span style="color:#66d9ef">uint64</span>  <span style="color:#66d9ef">float32</span>   <span style="color:#66d9ef">float64</span>     <span style="color:#66d9ef">complex64</span>   <span style="color:#66d9ef">complex128</span>
</span></span></code></pre></div><p>其中string和bool类型比较特殊，这个后面讨论。</p>
<p>然后 byte 类型是uint8的别名，rune是int32的别名。</p>
<p>平台相关的数据类型有：</p>
<ul>
<li>uint：int32 或者是 int64，看机子类型</li>
<li>uintptr：足够表示指针大小的无符号整数类型</li>
</ul>
<p>这些基本类型在内存中的表示如：</p>
<p><img src="https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gaddk6zal0j205g02n0q0.jpg" alt="1577585835.jpg"></p>
<h3 id="数组和切片">数组和切片<a href="#数组和切片" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<h4 id="数组">数组<a href="#数组" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>对于数组来说，如：<code>var arr = [5]byte{1,2,3,4,5}</code></p>
<p><img src="https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gaddpwa2bvj208x02rwe9.jpg" alt="1577586159(https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gaddpwa2bvj208x02rwe9.jpg).jpg"></p>
<p>对于arr这个[5]byte类型，他的内存就是5个连续的字节, 一个数组的定义同时包括了长度和类型。
比如：<code>var a [4]int</code>，那么就表示声明了一个类型是数组，元素类型是int，长度是4。这里需要注意的是Go语言的数组和C语言的不一样，C语言的数组是一个指针，指向数组的一个元素。但是在Go语言里面数组就是一个普通的值类型。而不是一个指向数组内存起始位置的指针，也不能和同类型的指针进行转化。</p>
<p>所以[4]int和[5]int表示两种完全不同的类型。</p>
<h4 id="切片">切片<a href="#切片" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>在之前的一些<a href="https://mangoqiqi.github.io/2018/09/09/golang/">golang基础</a>里已经有一些切片类型的简单使用方法了，这里就来探究一下切片的底层数据结构和实现。</p>
<p>切片是对数组中一段数据的引用。在内存中它有三段数据组成：一个指向数据头的指针、切片的长度、切片的容量。长度是索引操作的上界，如：x[i] 。容量是切片操作的上界，如：x[i:j]。</p>
<p>比如我通过s := make([]byte, 5)当容量参数被忽略时，它默认为指定的长度，创建的切片内存如下：</p>
<p><img src="https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadealbq7nj208d02t741.jpg" alt="1577587354(https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadealbq7nj208d02t741.jpg).jpg"></p>
<p>如果我们通过修改切片引用的数据区域和大小，s = s[2:4], 那么就变成了如下的结构</p>
<p><img src="https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadee0257zj207x03pjr5.jpg" alt="1577587559(https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadee0257zj207x03pjr5.jpg).jpg"></p>
<p>我们通过下面的代码可以很快弄清楚slice的内存模型</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">sliceA</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">len</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> [<span style="color:#ae81ff">5</span>]<span style="color:#66d9ef">byte</span>{<span style="color:#ae81ff">0</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>[:]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">sliceA</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ptr</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> = <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">sliceA</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ptr</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出结果如下</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0xc042038448</span>
</span></span><span style="display:flex;"><span>{<span style="color:#ae81ff">0xc042038448</span> <span style="color:#ae81ff">5</span> <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>{<span style="color:#ae81ff">0xc04203844a</span> <span style="color:#ae81ff">2</span> <span style="color:#ae81ff">3</span>}
</span></span></code></pre></div><p>0xc04203844a - 0xc042038448 = 2， 刚好是偏移了两个byte。</p>
<p>从上面的内存模型来看，如果两个数组相互赋值，那么将会触发数组全量拷贝的动作，但是如果是传递切片，那么将只需要永远申请固定大小的切片对象就可以了，底层的数组通过引用传递。</p>
<h4 id="切片的内存增长">切片的内存增长<a href="#切片的内存增长" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h4>
<p>从内存模型来看，切片就是引用了一个固定的数组， 一个切片的容量受到起始索引和底层数组容量的限制。Go语言提供了内置的copy和append函数来增长切片的容量，那么调用这些函数以后切片的内存会发生什么变化呢？</p>
<p>copy和append这两个是内置函数，是看不到go源码实现，可能使用C/C++/汇编实现的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> copy(<span style="color:#a6e22e">dst</span>, <span style="color:#a6e22e">src</span> []<span style="color:#a6e22e">Type</span>) <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> append(<span style="color:#a6e22e">slice</span> []<span style="color:#a6e22e">Type</span>, <span style="color:#a6e22e">elems</span> <span style="color:#f92672">...</span><span style="color:#a6e22e">Type</span>) []<span style="color:#a6e22e">Type</span>
</span></span></code></pre></div><p><em>copy方法</em></p>
<p>copy方法并不会修改slice的内存模型，仅仅是将某个slice的内容拷贝到另外一个slice中去。底层的实现在runtime\slice.go中，这个方法比较简单，就不赘述了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">slicecopy</span>(<span style="color:#a6e22e">to</span>, <span style="color:#a6e22e">fm</span> <span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">width</span> <span style="color:#66d9ef">uintptr</span>) <span style="color:#66d9ef">int</span>
</span></span></code></pre></div><p><em>append方法</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">sliceA</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">len</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">sliceA</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ptr</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// a == []int{0}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">a</span> = append(<span style="color:#a6e22e">a</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// a == []int{0, 1, 2, 3}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ptr</span> = <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">sliceA</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ptr</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">输出结果是</span><span style="color:#960050;background-color:#1e0010">：</span>
</span></span><span style="display:flex;"><span>{<span style="color:#ae81ff">0xc04203a448</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">1</span>}
</span></span><span style="display:flex;"><span>{<span style="color:#ae81ff">0xc0420369e0</span> <span style="color:#ae81ff">4</span> <span style="color:#ae81ff">4</span>}
</span></span></code></pre></div><p>那么从上面可以看出，append方法其实重新生成了一个新的数组，然后返回的切片引用了这个新的数组，那我们来重点看一下append方法的实现，为了简单点，写出下面的代码，然后生成汇编：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">byte</span>{<span style="color:#e6db74">&#39;a&#39;</span>}
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">b</span> = append(<span style="color:#a6e22e">b</span>, <span style="color:#e6db74">&#39;b&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(string(<span style="color:#a6e22e">b</span>), cap(<span style="color:#a6e22e">b</span>))  <span style="color:#75715e">// output : ab 8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>从下面的汇编可以得到两个信息：
runtime.growslice是用来实现slice增长的函数
cap函数的实现仅仅是调用b.cap这个成员</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#e6db74">&#34;&#34;</span>.<span style="color:#a6e22e">main</span> <span style="color:#a6e22e">STEXT</span> <span style="color:#a6e22e">size</span>=<span style="color:#ae81ff">348</span> <span style="color:#a6e22e">args</span>=<span style="color:#ae81ff">0x0</span> <span style="color:#a6e22e">locals</span>=<span style="color:#ae81ff">0x80</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0036</span> <span style="color:#ae81ff">00054</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">LEAQ</span>	<span style="color:#66d9ef">type</span>.uint8(<span style="color:#a6e22e">SB</span>), <span style="color:#a6e22e">AX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x003d</span> <span style="color:#ae81ff">00061</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">PCDATA</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">2</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x003d</span> <span style="color:#ae81ff">00061</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">AX</span>, (<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0041</span> <span style="color:#ae81ff">00065</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">PCDATA</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">2</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0041</span> <span style="color:#ae81ff">00065</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">LEAQ</span>	<span style="color:#e6db74">&#34;&#34;</span>..<span style="color:#a6e22e">autotmp_9</span><span style="color:#f92672">+</span><span style="color:#ae81ff">71</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">AX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0046</span> <span style="color:#ae81ff">00070</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">PCDATA</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">2</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0046</span> <span style="color:#ae81ff">00070</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">AX</span>, <span style="color:#ae81ff">8</span>(<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x004b</span> <span style="color:#ae81ff">00075</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">16</span>(<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0054</span> <span style="color:#ae81ff">000</span><span style="color:#ae81ff">84</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">24</span>(<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x005d</span> <span style="color:#ae81ff">000</span><span style="color:#ae81ff">93</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">32</span>(<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0066</span> <span style="color:#ae81ff">00102</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">growslice</span>(<span style="color:#a6e22e">SB</span>)  <span style="color:#75715e">// 实现slice增长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#ae81ff">0x006b</span> <span style="color:#ae81ff">00107</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">PCDATA</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">2</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x006b</span> <span style="color:#ae81ff">00107</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#ae81ff">40</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">AX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0070</span> <span style="color:#ae81ff">00112</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#ae81ff">48</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">CX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0075</span> <span style="color:#ae81ff">00117</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#ae81ff">56</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">DX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x007a</span> <span style="color:#ae81ff">00122</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">DX</span>, <span style="color:#e6db74">&#34;&#34;</span>.<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">cap</span><span style="color:#f92672">+</span><span style="color:#ae81ff">72</span>(<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x007f</span> <span style="color:#ae81ff">00127</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">MOVB</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">98</span>, <span style="color:#ae81ff">1</span>(<span style="color:#a6e22e">AX</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0083</span> <span style="color:#ae81ff">00131</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>, (<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x008b</span> <span style="color:#ae81ff">0013</span><span style="color:#ae81ff">9</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">PCDATA</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">2</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x008b</span> <span style="color:#ae81ff">0013</span><span style="color:#ae81ff">9</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">AX</span>, <span style="color:#ae81ff">8</span>(<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0090</span> <span style="color:#ae81ff">00144</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">9</span>)	<span style="color:#a6e22e">LEAQ</span>	<span style="color:#ae81ff">1</span>(<span style="color:#a6e22e">CX</span>), <span style="color:#a6e22e">AX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0094</span> <span style="color:#ae81ff">0014</span><span style="color:#ae81ff">8</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">AX</span>, <span style="color:#ae81ff">16</span>(<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x0099</span> <span style="color:#ae81ff">00153</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">DX</span>, <span style="color:#ae81ff">24</span>(<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x009e</span> <span style="color:#ae81ff">0015</span><span style="color:#ae81ff">8</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">slicebytetostring</span>(<span style="color:#a6e22e">SB</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x00a3</span> <span style="color:#ae81ff">00163</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#ae81ff">40</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">AX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x00a8</span> <span style="color:#ae81ff">0016</span><span style="color:#ae81ff">8</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">PCDATA</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">2</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x00a8</span> <span style="color:#ae81ff">0016</span><span style="color:#ae81ff">8</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#ae81ff">32</span>(<span style="color:#a6e22e">SP</span>), <span style="color:#a6e22e">CX</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x00ad</span> <span style="color:#ae81ff">00173</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">PCDATA</span>	<span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">2</span>, <span style="color:#960050;background-color:#1e0010">$</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x00ad</span> <span style="color:#ae81ff">00173</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">CX</span>, (<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x00b1</span> <span style="color:#ae81ff">00177</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">MOVQ</span>	<span style="color:#a6e22e">AX</span>, <span style="color:#ae81ff">8</span>(<span style="color:#a6e22e">SP</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ae81ff">0x00b6</span> <span style="color:#ae81ff">001</span><span style="color:#ae81ff">82</span> (<span style="color:#a6e22e">goslice</span>.<span style="color:#66d9ef">go</span>:<span style="color:#ae81ff">10</span>)	<span style="color:#a6e22e">CALL</span>	<span style="color:#a6e22e">runtime</span>.<span style="color:#a6e22e">convTstring</span>(<span style="color:#a6e22e">SB</span>)
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span></code></pre></div><p>growslice的实现：src\runtime\slice.go</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">growslice</span>(<span style="color:#a6e22e">et</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>, <span style="color:#a6e22e">old</span> <span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">slice</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">newcap</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">old</span>.<span style="color:#a6e22e">cap</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">doublecap</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">newcap</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">newcap</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">cap</span> &gt; <span style="color:#a6e22e">doublecap</span> {                 <span style="color:#75715e">// 如果新的大小是当前大小2倍以上，则大小增长为新大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">newcap</span> = <span style="color:#a6e22e">cap</span>
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">old</span>.<span style="color:#a6e22e">len</span> &lt; <span style="color:#ae81ff">1024</span> {              <span style="color:#75715e">// 如果当前大小小于1024，按每次2倍增长
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#a6e22e">newcap</span> = <span style="color:#a6e22e">doublecap</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {                         <span style="color:#75715e">// 否则每次按当前大小1/4增长，直到增长的大小超过或等于新大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">newcap</span> &lt; <span style="color:#a6e22e">cap</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">newcap</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">newcap</span> <span style="color:#f92672">/</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">......</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">et</span>.<span style="color:#a6e22e">kind</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">kindNoPointers</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">p</span> = <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">capmem</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">memmove</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">old</span>.<span style="color:#a6e22e">array</span>, <span style="color:#a6e22e">lenmem</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// Only clear the part that will not be overwritten.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">memclrNoHeapPointers</span>(<span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">newlenmem</span>), <span style="color:#a6e22e">capmem</span><span style="color:#f92672">-</span><span style="color:#a6e22e">newlenmem</span>)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Note: can&#39;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">p</span> = <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">capmem</span>, <span style="color:#a6e22e">et</span>, <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">writeBarrier</span>.<span style="color:#a6e22e">enabled</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">memmove</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">old</span>.<span style="color:#a6e22e">array</span>, <span style="color:#a6e22e">lenmem</span>)
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">lenmem</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">et</span>.<span style="color:#a6e22e">size</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">et</span>, <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">i</span>), <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">old</span>.<span style="color:#a6e22e">array</span>, <span style="color:#a6e22e">i</span>))
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">slice</span>{<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">old</span>.<span style="color:#a6e22e">len</span>, <span style="color:#a6e22e">newcap</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>具体实现的代码就不说了，其实就是判断cap，生成一个新的数组，将old的元素拷贝到新的slice中去。
扩容规则上面的代码已经说明了：</p>
<p>如果新的大小是当前大小2倍以上，则大小增长为新大小，
否则循环以下操作：如果当前大小小于1024，按每次2倍增长，否则每次按当前大小1/4增长。直到增长的大小超过或等于新大小。</p>
<p>在runtime\slice.go中，我们可以看到</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">slice</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">array</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">len</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cap</span>   <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个也是Go语言内部的slice数据结构，和我们前面定义的是一致的，slice的make，copy，grow等函数都在这个文件中实现</p>
<p><em>字符串</em></p>
<p>字符串在内存中其实表示成了这么一个数据结构
这个定义是在runtime\string.go中定义的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">stringStruct</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">str</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">len</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;hello&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">stringStruct</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ptr</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">s</span>[:<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> = <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">stringStruct</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ptr</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span> = <span style="color:#a6e22e">s</span>[<span style="color:#ae81ff">2</span>:<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> = <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">stringStruct</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ptr</span>)
</span></span></code></pre></div><p>从上面的代码可以输出如下的结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span>{<span style="color:#ae81ff">0x4b1cbe</span> <span style="color:#ae81ff">5</span>}
</span></span><span style="display:flex;"><span>{<span style="color:#ae81ff">0x4b1cbe</span> <span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>{<span style="color:#ae81ff">0x4b1cc0</span> <span style="color:#ae81ff">1</span>}
</span></span></code></pre></div><p>所以说，字符串也是一种特殊的切片，但是是没有容量，只有长度属性。</p>
<h2 id="map的实现">map的实现<a href="#map的实现" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Go语言的map并不是像C++的map一样用二叉树实现的，而是典型Hash实现的。</p>
<p>定义一个map：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">Map</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>        <span style="color:#75715e">// 只是定义，没有分配空间，不能使用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">Map</span> = make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>)    <span style="color:#75715e">// 分配空间
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">cMap</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">string</span>]<span style="color:#66d9ef">string</span>)  <span style="color:#75715e">// 也可以这样
</span></span></span></code></pre></div><p>在src\runtime\map.go里面可以找到具体的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">hmap</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">count</span>     <span style="color:#66d9ef">int</span>              <span style="color:#75715e">// count 用于记录当前哈希表元素数量，这个字段让我们不再需要去遍历整个哈希表来获取长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">flags</span>     <span style="color:#66d9ef">uint8</span>            <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">B</span>         <span style="color:#66d9ef">uint8</span>            <span style="color:#75715e">// 表示了当前哈希表持有的 buckets 数量，但是因为哈希表的扩容是以 2 倍数进行的，所以这里会使用对数来存储，我们可以简单理解成 len(buckets) == 2^B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">noverflow</span> <span style="color:#66d9ef">uint16</span>           <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">hash0</span>     <span style="color:#66d9ef">uint32</span>           <span style="color:#75715e">// 哈希种子，这个值会在调用哈希函数的时候作为参数传进去，它的主要作用就是为哈希函数的结果引入一定的随机性
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">buckets</span>    <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>  <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">oldbuckets</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>  <span style="color:#75715e">// 哈希在扩容时用于保存之前 buckets 的字段，它的大小都是当前 buckets 的一半；
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">nevacuate</span>  <span style="color:#66d9ef">uintptr</span>         <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">extra</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">mapextra</span>            <span style="color:#75715e">// 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>go语言的map其实就是一个bucket的数组，这个数组的大小永远是2的次幂。
具体的实现可以在这里看到：<a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/</a></p>
<h2 id="struct结构体">struct结构体<a href="#struct结构体" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>Go语言里面的结构体内存模型和C语言里面一样的，都是连续的内存，如果是指针，那么就通过指针跳转</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-GO" data-lang="GO"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Point</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">X</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Y</span> <span style="color:#66d9ef">int</span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>那么内存模型就是：</p>
<p><img src="https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadflnr12fj203t039dfl.jpg" alt="1577590070(https://hindung.oss-cn-beijing.aliyuncs.com/img/9dc4c374gy1gadflnr12fj203t039dfl.jpg).jpg"></p>
<h3 id="struct的字节对齐">struct的字节对齐<a href="#struct的字节对齐" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h3>
<p>在64位系统上面，Go语言的字节是8直接对齐，如果不足的，就补充padding。
这里有详细的描述：<a href="http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/">http://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/</a></p>
<p>下面有一个简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Example</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">BoolValue</span> <span style="color:#66d9ef">bool</span>          <span style="color:#75715e">// 1 byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">IntValue</span> <span style="color:#66d9ef">int16</span>          <span style="color:#75715e">// 2 byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">FloatValue</span> <span style="color:#66d9ef">float32</span>      <span style="color:#75715e">// 4 byte
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">example</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Example</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">BoolValue</span>:  <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">IntValue</span>:   <span style="color:#ae81ff">10</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">FloatValue</span>: <span style="color:#ae81ff">3.141592</span>,
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">alignmentBoundary</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Alignof</span>(<span style="color:#a6e22e">example</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sizeBool</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">BoolValue</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">offsetBool</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Offsetof</span>(<span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">BoolValue</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sizeInt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">IntValue</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">offsetInt</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Offsetof</span>(<span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">IntValue</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">sizeFloat</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">FloatValue</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">offsetFloat</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Offsetof</span>(<span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">FloatValue</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;size Example: %d\n&#34;</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">example</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Alignment Boundary: %d\n&#34;</span>, <span style="color:#a6e22e">alignmentBoundary</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;BoolValue = Size: %d Offset: %d Addr: %v\n&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sizeBool</span>, <span style="color:#a6e22e">offsetBool</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">BoolValue</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;IntValue = Size: %d Offset: %d Addr: %v\n&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sizeInt</span>, <span style="color:#a6e22e">offsetInt</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">IntValue</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;FloatValue = Size: %d Offset: %d Addr: %v\n&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sizeFloat</span>, <span style="color:#a6e22e">offsetFloat</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">example</span>.<span style="color:#a6e22e">FloatValue</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>输出结果如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#a6e22e">size</span> <span style="color:#a6e22e">Example</span>: <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Alignment</span> <span style="color:#a6e22e">Boundary</span>: <span style="color:#ae81ff">8</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">BoolValue</span> = <span style="color:#a6e22e">Size</span>: <span style="color:#ae81ff">1</span> <span style="color:#a6e22e">Offset</span>: <span style="color:#ae81ff">0</span> <span style="color:#a6e22e">Addr</span>: <span style="color:#ae81ff">0xc04200a230</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">IntValue</span> = <span style="color:#a6e22e">Size</span>: <span style="color:#ae81ff">2</span> <span style="color:#a6e22e">Offset</span>: <span style="color:#ae81ff">2</span> <span style="color:#a6e22e">Addr</span>: <span style="color:#ae81ff">0xc04200a232</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">FloatValue</span> = <span style="color:#a6e22e">Size</span>: <span style="color:#ae81ff">4</span> <span style="color:#a6e22e">Offset</span>: <span style="color:#ae81ff">4</span> <span style="color:#a6e22e">Addr</span>: <span style="color:#ae81ff">0xc04200a234</span>
</span></span></code></pre></div><p>可以看出在64位机器是按照8字节对齐的，并且bool的后面增加了一个字节的padding</p>
<h2 id="make和new">make和new<a href="#make和new" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>在Go语言里面有两种方式来创建数据结构：new和make</p>
<p>切片、map和通道，使用make，
数组、结构体和所有的值类型，使用new，
因为new仅仅是分配内存，但是make还包括了初始化，
因为slice，map和channel在底层实现的时候并不是一个简单的值，而是一个数据结构，并且这个数据结构中要初始化以后才能使用。并且make不是返回指针，而是返回一个<em>类型</em>。</p>
<p>对于切片，使用new和make的区别：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">sliceA</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">len</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> new([]<span style="color:#66d9ef">int</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">sliceA</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">p</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ptr</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">q</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ptr</span> = <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">sliceA</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">q</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ptr</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">// ouput:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>{&lt;<span style="color:#66d9ef">nil</span>&gt; <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>}
</span></span><span style="display:flex;"><span>{<span style="color:#ae81ff">0x5811b0</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">0</span>}
</span></span></code></pre></div><p>我们来看一下slice的make做了啥：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makeslice</span>(<span style="color:#a6e22e">et</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>, <span style="color:#a6e22e">len</span>, <span style="color:#a6e22e">cap</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mem</span>, <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MulUintptr</span>(<span style="color:#a6e22e">et</span>.<span style="color:#a6e22e">size</span>, uintptr(<span style="color:#a6e22e">cap</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">mem</span> &gt; <span style="color:#a6e22e">maxAlloc</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">len</span> &lt; <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">len</span> &gt; <span style="color:#a6e22e">cap</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// NOTE: Produce a &#39;len out of range&#39; error instead of a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// &#39;cap out of range&#39; error when someone does make([]T, bignumber).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// &#39;cap out of range&#39; is true too, but since the cap is only being
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// supplied implicitly, saying len is clearer.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// See golang.org/issue/4085.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#a6e22e">mem</span>, <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MulUintptr</span>(<span style="color:#a6e22e">et</span>.<span style="color:#a6e22e">size</span>, uintptr(<span style="color:#a6e22e">len</span>))
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">mem</span> &gt; <span style="color:#a6e22e">maxAlloc</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">len</span> &lt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">panicmakeslicelen</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">panicmakeslicecap</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">mem</span>, <span style="color:#a6e22e">et</span>, <span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从上面来看，最重要就是通过mallocgc来申请了一个数组。</p>
<p>通过查看汇编代码就可以看出make底层是调用哪个函数了:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Go" data-lang="Go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">makemap</span>(<span style="color:#a6e22e">t</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">maptype</span>, <span style="color:#a6e22e">hint</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">h</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">hmap</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">hmap</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mem</span>, <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">math</span>.<span style="color:#a6e22e">MulUintptr</span>(uintptr(<span style="color:#a6e22e">hint</span>), <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">bucket</span>.<span style="color:#a6e22e">size</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">overflow</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">mem</span> &gt; <span style="color:#a6e22e">maxAlloc</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">hint</span> = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// initialize Hmap
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">h</span> = new(<span style="color:#a6e22e">hmap</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">hash0</span> = <span style="color:#a6e22e">fastrand</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Find the size parameter B which will hold the requested # of elements.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">B</span> <span style="color:#f92672">:=</span> uint8(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">overLoadFactor</span>(<span style="color:#a6e22e">hint</span>, <span style="color:#a6e22e">B</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">B</span><span style="color:#f92672">++</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span> = <span style="color:#a6e22e">B</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// allocate initial hash table
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// if B == 0, the buckets field is allocated lazily later (in mapassign)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// If hint is large zeroing this memory could take a while.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">nextOverflow</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bmap</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">buckets</span>, <span style="color:#a6e22e">nextOverflow</span> = <span style="color:#a6e22e">makeBucketArray</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">B</span>, <span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nextOverflow</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span> = new(<span style="color:#a6e22e">mapextra</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">h</span>.<span style="color:#a6e22e">extra</span>.<span style="color:#a6e22e">nextOverflow</span> = <span style="color:#a6e22e">nextOverflow</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">h</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>从上面看，map初始化最重要的就是创建buckets。</p>
<h2 id="总结">总结<a href="#总结" class="hanchor" ariaLabel="Anchor">&#8983;</a> </h2>
<p>整体来说，Go语言的对象内存模型比C++要简单的多并且与C很像，毕竟没有继承，虚函数，多重继承等等，了解这些内存模型，对于平时使用这些类型时可以少踩坑是有帮助的。</p>
<p><em><strong>参考链接：</strong></em></p>
<p><a href="https://skyao.io/learning-go/grammar/type/basic.html">https://skyao.io/learning-go/grammar/type/basic.html</a></p>
<p><a href="https://studygolang.com/articles/9169">https://studygolang.com/articles/9169</a></p>
<p><a href="https://juejin.im/post/5ceffeddf265da1bc8540df5">使用map实现set</a></p>

      </div></div>

  
  
<div class="pagination">
    <div class="pagination__title">
        <span class="pagination__title-h">Read other posts</span>
        <hr />
    </div>
    <div class="pagination__buttons">
        
        <span class="button previous">
            <a href="http://hindung.cn/posts/5/">
                <span class="button__icon">←</span>
                <span class="button__text">Golang-channel</span>
            </a>
        </span>
        
        
        <span class="button next">
            <a href="http://hindung.cn/posts/3/">
                <span class="button__text">初探Gin框架</span>
                <span class="button__icon">→</span>
            </a>
        </span>
        
    </div>
</div>

  

  
  

  
</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2022 Powered by <a href="http://gohugo.io">Hugo</a></span>
    
        <span>:: Theme made by <a href="https://twitter.com/panr">panr</a></span>
      </div>
  </div>
</footer>

<script src="http://hindung.cn/assets/main.js"></script>
<script src="http://hindung.cn/assets/prism.js"></script>


  <script src="http://hindung.cn/assets/languageSelector.js"></script>






  
</div>

</body>
</html>
