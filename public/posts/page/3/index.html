<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Posts"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="http://hindung.cn/posts/"><title>Posts | Hindung Blogs</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.scss integrity crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.babd2f636c40f8c2a90eb07eec05db5d5b170c6461306029c9a468cc2daf879d.js integrity="sha256-ur0vY2xA+MKpDrB+7AXbXVsXDGRhMGApyaRozC2vh50=" crossorigin=anonymous></script>
<link rel=alternate type=application/rss+xml href=http://hindung.cn/posts/index.xml title="Hindung Blogs"></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Hindung Blogs</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Posts</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav><ul><li class=book-section-flat><strong>Categories</strong><ul></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/go/>Go</a>
<span>12</span></li><li class="flex justify-between"><a href=/tags/kubernetes/>Kubernetes</a>
<span>5</span></li><li class="flex justify-between"><a href=/tags/blog/>Blog</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/makerdown/>Makerdown</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/docker/>Docker</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/network/>Network</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/leetcode/>LeetCode</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/>核心竞争力</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/algorithm/>Algorithm</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/heap/>heap</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/queue/>queue</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gin/>Gin</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/dockerfile/>Dockerfile</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/markdown/>Markdown</a>
<span>1</span></li></ul></li></ul></nav></aside></header><article class="markdown book-post"><h2><a href=/posts/16/>深拷贝之循环引用</a></h2><h5>May 8, 2021</h5><div><a href=/tags/leetcode/>LeetCode</a>,
<a href=/tags/go/>Go</a></div><p>题目 # 实现如下结构体的深拷贝。
type Node struct { Data int Fields []*Node } 即指针指向的内存也需要Copy一份。
解析 # 观察结构体，由于Fields字段里存放的是指向Node结构体的指针切片，深拷贝时要考虑循环引用的问题，如：
struct a : data: 1 fields: b, c struct b: data: 2 fields: c struct c: data: 3 fields: a // 这里循环引用了a， c->a->b, c->a 可以考虑使用map[*Node]*Node来判断是否有环的情况，即用map[src] = dst来保存拷贝过的节点。
代码 # 代码如下：
package main import ( "go/ast" "go/token" ) type Node struct { Data int Fields []*Node } // deep copy var M map[*Node]*Node func Dup(src *Node) *Node { if src == nil { return nil } node := &amp;Node{ Data: src.
<a href=/posts/16/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/15/>LRU 缓存机制</a></h2><h5>May 6, 2021</h5><div><a href=/tags/leetcode/>LeetCode</a></div><p>题目 # 146. LRU 缓存机制
解析 # 由于要求要用O(1)的时间复杂度，所以要采用双向链表＋map的数据结构解答。
具体源码如下：
package main import "fmt" type LRUCache struct { M map[int]*Node Cap int Size int Head, Tail *Node } type Node struct { Key, Value int Pre, Next *Node } // init LRUCache func Constructor(capacity int) LRUCache { l := LRUCache{ M: map[int]*Node{}, Cap: capacity, Size: 0, Head: &amp;Node{ Key: 0, Value: 0, Pre: nil, Next: nil, }, Tail: &amp;Node{ Key: 0, Value: 0, Pre: nil, Next: nil, }, } // nil&lt;-head&lt;->tail-> l.
<a href=/posts/15/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/14/>Go源码解读之sync/atomic</a></h2><h5>April 29, 2021</h5><div><a href=/tags/go/>Go</a></div><p>注：go version 1.16.x
Overview # 从网站pkg.go.dev上可以看到，对应的解释。
atomic包提供了用于实现同步算法的低级原子内存原语。
可以分为几类操作：
Add操作：加减操作 CAS操作：先比较后赋值操作 Swap操作：赋值操作 Load操作：从某个地址中取值 Store操作：往某个地址赋值 Value类型：对任意类型的Load/Store操作封装 操作分类 # Add操作 # 由AddT函数实现的加法操作在原子上等效于：
*addr += delta \\ 加上步长 正负数都可以 return *addr \\ 反回加后的结果 相关的方法有：
func AddInt32(addr *int32, delta int32) (new int32) func AddUint32(addr *uint32, delta uint32) (new uint32) func AddInt64(addr *int64, delta int64) (new int64) func AddUint64(addr *uint64, delta uint64) (new uint64) func AddUintptr(addr *uintptr, delta uintptr) (new uintptr) CAS操作 # CAS即CompareAndSwap，这个函数主要就是先比较一下当前传入的地址的值是否和 old 值相等，如果相等，就赋值新值返回 true，如果不相等就返回 false.
<a href=/posts/14/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/13/>使用Go遇到的坑</a></h2><h5>April 1, 2021</h5><div><a href=/tags/go/>Go</a></div><p>for range 语句中的值传递问题 # package main import "fmt" var pow = []int{1, 2, 4} func main() { for _, v := range pow { v++ } for _, v := range pow { fmt.Println(v) } } //out put : 1 2 4 原因：for range创建了每个元素的副本，而不是直接返回每个元素的引用。
IPv4与IPv6格式问题 # Go中IPv4的长度和IPv6的长度是一样的，都是16Byte存储，故不能使用len()函数去区别:
conn, err := net.Dial("udp", "8.9.10.11:2342") if err != nil { fmt.Println("Error", err) } localaddr := conn.LocalAddr() addr, _ := net.ResolveUDPAddr("udp", localaddr.String()) ip := addr.
<a href=/posts/13/>...</a></p></article><article class="markdown book-post"><h2><a href=/posts/12/>构建属于你自己的核心力量</a></h2><h5>October 2, 2020</h5><div><a href=/tags/%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/>核心竞争力</a></div><p>前言 # Bridging the Gap Between Junior and Senior Engineers这篇文章是偶然在公众号看到的，觉得里面说的从Junior如何向Senior Engineers发展以及所需要掌握的技能，我觉得说的挺好的，这里就翻译过来，做为以后反省的清单吧，向大佬靠齐！
部分原文译文 # 从Junior向Senior Engineers发展应该关注的一些问题：
编码硬实力是基本的能力。
你的代码的可维护性如何？是否有其他工程师不停地轻敲你的肩膀，让你解释你代码的每一行都是如何工作的？你的变量名具有描述性吗？你的方法是直观、易理解的吗？当你发现自己在复制粘贴很多行代码时，你是否能将这些代码的功能写入可重用的服务中？
别人能够从你在拉取请求(PR)中留下的评论中受益吗？你的反馈意见是有建设性，还是太过粗糙？当你发现别人的知识存在缺口时，你只是告诉他们“把这条线从 ABC 更改为 XYZ”，还是有能力引导他们认识到自己的方法可能不是最佳方法，让他们成长为更优秀的开发者？毕竟，同样是学习新东西，授人以鱼不如授之以渔。
你知道如何基准化你的更改并进行证明、测试吗？如果今天有 100,000 个用户创建帐户，你的代码是否会开始引发大量超时和 500 个错误？你能保证你的PR（合并请求）能够解决这些问题吗？
你如何将非常技术的问题分解为公司其他部门可以理解的简单语言？向市场解释为什么一个功能实际上不可行时，你是否会让大量的工程术语从嘴里溜出来？
你对面向对象的编程有深刻的了解吗？你提出的系统架构是不是“顶多算说得通”？
你的写作能力如何？在回复电子邮件时，你是能把自己的意思表达清楚，还是发完邮件后同事仍然需要走到你的办公桌旁，来询问你更多的背景信息？
你是否会主动提出想法，使你的团队效率更高？当需要改动现有进程时，你是否能够向所有参与方说明收益？你能使所有人都对这一变化感到兴奋吗？你是否可以持续跟进，并确保新流程确实有效？
你尊重别人的时间吗？当你要求别人帮助你解决问题时，你能否准确描述你遇到问题的代码库的确切定位（如抛出异常的行号、你在问别人之前已经尝试过的 debug 方法，免得别人再浪费时间重复你已经做过的工作）？别人是否必须反复问你，才能从你嘴里撬出这些信息？在别人走到你办公桌前，你已经整理好要问的问题并在 MacBook 上打开了吗？
在与其他部门一起确定大型项目的范围时，你对要开发的新功能的问题了解得有多深入？在开始编码之前，你是否能够考虑到每个边缘情况？你是否能够及早识别范围蔓延并尽早制止，从而使团队免于周六加班？
你的多任务处理能力如何？你的大脑会超负荷吗？同样，在处理大型功能时，比如涉及 50 个文件的功能……你可以一次将它们全部保存在脑海中吗？你有养成扎实的记笔记习惯吗？你打算如何计划跟踪今天下班前弹出的 500 万件事？
当你编写的一段代码导致帐单页面出错，搞得团队首席工程师不得不取消他们的晚餐计划、熬夜帮你解决问题时，你会如何应对？你会情绪激动吗？你还能理性思考吗？你是否能够摆脱这种情绪，并提醒自己，地球上的每个开发人员每两天就会发布错误代码？
你了解业务运作方式吗？你了解为什么即使失业人数达到两位数，软件工程师也可以要求如此疯狂的薪水吗？为什么编程是如此宝贵的技能？为什么客户愿意为某些超级基本的 Web 表单向你的公司每年支付 50,000 美元？你是否觉得他们被骗了？
领导可以放心地让你去负责面试候选人吗？你是否擅长通过有限的信息来对人员进行分类，并可视化他们和团队的适合程度？你能识别出在什么情况下，在工程方面优秀的候选人却不能很好地融入公司文化吗？这种候选人你会建议录取吗？同样，即使你和候选人在 Zoom 里聊了 5 分钟就知道他不可能被录取，你是否还可以确保他仍然可以从你们的聊天中学到东西？毕竟，语言在网络上的传播速度是很快的。
假如今天是 12 月 28 日，你被困在办公室。你今年有点疯狂，在 9 月中旬就把今年所有的带薪休假糟蹋完了。此时此刻，同事们都休假出去 high 了。你还能按时上班吗？领导不在身边惩罚你，你是否打算半途而废？这种情形下，是否需要领导强迫你你才能尽全力工作？
机会成本是一件必须考虑的事。你在平衡技术债务和推动业务发展方面做得如何？你是否会重构发现的每个微小的编码样式问题？毕竟大家都很难承认“这段代码很烦人，但它确实有效，需要花费四个小时的清理时间，这段时间可以花在构建其他功能上，而这是很多客户都在请求的”。
你知道如何向你的下属反馈 他们 的绩效吗？你和他们有良好的工作关系吗？你是否将他们视为敌人？你是否正在积极尝试减轻他们的压力，使他们的生活更轻松？你是否曾经说过“你们那边有什么烦人的任务我可以帮忙削减吗”？公司雇人都是有原因的，你的下属可能比你想象的更有经验和资格。
你有能力扑灭生产大火吗？你是否会在遇到 大麻烦 时惊慌、不知所措（比如 AWS 中断使网站瘫痪、不小心搞丢了 customer_invoices 表单、某些错误导致了不同用户帐户之间的数据泄漏等）？你是会在压力之下崩溃，还是会在解决问题的同时保持镇静，并与其他部门进行有效的沟通？
<a href=/posts/12/>...</a></p></article><ul class="pagination pagination-default"><li class=page-item><a href=/posts/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/posts/page/2/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/posts/ aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/posts/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class="page-item active"><a aria-current=page aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/posts/page/4/ aria-label="Page 4" class=page-link role=button>4</a></li><li class=page-item><a href=/posts/page/5/ aria-label="Page 5" class=page-link role=button>5</a></li><li class=page-item><a href=/posts/page/4/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/posts/page/5/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav><ul><li class=book-section-flat><strong>Categories</strong><ul></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/tags/go/>Go</a>
<span>12</span></li><li class="flex justify-between"><a href=/tags/kubernetes/>Kubernetes</a>
<span>5</span></li><li class="flex justify-between"><a href=/tags/blog/>Blog</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/makerdown/>Makerdown</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/docker/>Docker</a>
<span>3</span></li><li class="flex justify-between"><a href=/tags/network/>Network</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/leetcode/>LeetCode</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B/>核心竞争力</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/algorithm/>Algorithm</a>
<span>2</span></li><li class="flex justify-between"><a href=/tags/heap/>heap</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/queue/>queue</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/gin/>Gin</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/dockerfile/>Dockerfile</a>
<span>1</span></li><li class="flex justify-between"><a href=/tags/markdown/>Markdown</a>
<span>1</span></li></ul></li></ul></nav></div></aside></main></body></html>