<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Go源码探究系列，基于golang 1.16.x版本"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="Go源码解读之sync/atomic"><meta property="og:description" content="Go源码探究系列，基于golang 1.16.x版本"><meta property="og:type" content="article"><meta property="og:url" content="http://hindung.cn/posts/14/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-29T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-29T00:00:00+00:00"><title>Go源码解读之sync/atomic | Hindung Blogs</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.scss integrity crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.babd2f636c40f8c2a90eb07eec05db5d5b170c6461306029c9a468cc2daf879d.js integrity="sha256-ur0vY2xA+MKpDrB+7AXbXVsXDGRhMGApyaRozC2vh50=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Hindung Blogs</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Go源码解读之sync/atomic</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#add操作>Add操作</a></li><li><a href=#cas操作>CAS操作</a><ul><li><a href=#cas不能解决的问题>CAS不能解决的问题</a></li></ul></li><li><a href=#swap操作>Swap操作</a></li><li><a href=#load操作>Load操作</a></li><li><a href=#store操作>Store操作</a></li><li><a href=#value类型>Value类型</a></li></ul><ul><li><a href=#例子cowcopy-on-write>例子COW(Copy On Write)</a></li></ul></nav></aside></header><article class=markdown><h1><a href=/posts/14/>Go源码解读之sync/atomic</a></h1><h5>April 29, 2021</h5><div><a href=/tags/go/>Go</a></div><p><em>注：go version 1.16.x</em></p><h1 id=overview>Overview
<a class=anchor href=#overview>#</a></h1><p>从网站<a href=https://pkg.go.dev/sync/atomic>pkg.go.dev</a>上可以看到，对应的解释。</p><p>atomic包提供了用于实现同步算法的低级原子内存原语。</p><p>可以分为几类操作：</p><ul><li>Add操作：加减操作</li><li>CAS操作：先比较后赋值操作</li><li>Swap操作：赋值操作</li><li>Load操作：从某个地址中取值</li><li>Store操作：往某个地址赋值</li><li>Value类型：对任意类型的Load/Store操作封装</li></ul><h1 id=操作分类>操作分类
<a class=anchor href=#%e6%93%8d%e4%bd%9c%e5%88%86%e7%b1%bb>#</a></h1><h2 id=add操作>Add操作
<a class=anchor href=#add%e6%93%8d%e4%bd%9c>#</a></h2><p>由AddT函数实现的加法操作在原子上等效于：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>delta</span>  <span style=color:#960050;background-color:#1e0010>\\</span> <span style=color:#a6e22e>加上步长</span> <span style=color:#a6e22e>正负数都可以</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span>    <span style=color:#960050;background-color:#1e0010>\\</span> <span style=color:#a6e22e>反回加后的结果</span>
</span></span></code></pre></div><p>相关的方法有：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AddInt32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>delta</span> <span style=color:#66d9ef>int32</span>) (<span style=color:#a6e22e>new</span> <span style=color:#66d9ef>int32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AddUint32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>delta</span> <span style=color:#66d9ef>uint32</span>) (<span style=color:#a6e22e>new</span> <span style=color:#66d9ef>uint32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AddInt64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>delta</span> <span style=color:#66d9ef>int64</span>) (<span style=color:#a6e22e>new</span> <span style=color:#66d9ef>int64</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AddUint64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>delta</span> <span style=color:#66d9ef>uint64</span>) (<span style=color:#a6e22e>new</span> <span style=color:#66d9ef>uint64</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>AddUintptr</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>delta</span> <span style=color:#66d9ef>uintptr</span>) (<span style=color:#a6e22e>new</span> <span style=color:#66d9ef>uintptr</span>)
</span></span></code></pre></div><h2 id=cas操作>CAS操作
<a class=anchor href=#cas%e6%93%8d%e4%bd%9c>#</a></h2><p>CAS即CompareAndSwap，这个函数主要就是先比较一下当前传入的地址的值是否和 old 值相等，如果相等，就赋值新值返回 true，如果不相等就返回 false.</p><p>利用这个方法可以实现锁机制。</p><p>相关的方法有：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CompareAndSwapInt32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>int32</span>) (<span style=color:#a6e22e>swapped</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CompareAndSwapInt64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>int64</span>) (<span style=color:#a6e22e>swapped</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CompareAndSwapUint32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>uint32</span>) (<span style=color:#a6e22e>swapped</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CompareAndSwapUint64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>uint64</span>) (<span style=color:#a6e22e>swapped</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CompareAndSwapUintptr</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>uintptr</span>) (<span style=color:#a6e22e>swapped</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CompareAndSwapPointer</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>old</span>, <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) (<span style=color:#a6e22e>swapped</span> <span style=color:#66d9ef>bool</span>)
</span></span></code></pre></div><p>从源码<a href=https://go.googlesource.com/go/+/go1.16.3/src/runtime/internal/atomic/asm_amd64.s#17>runtime/internal/atomic/asm_amd64.s</a>中可以看到CAS对应的汇编指令实现。
如<code>CompareAndSwapInt32</code>方法的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// bool Cas(int32 *val, int32 old, int32 new)
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Atomically:
</span></span></span><span style=display:flex><span><span style=color:#75715e>//	if(*val == old){
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		*val = new;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		return 1;
</span></span></span><span style=display:flex><span><span style=color:#75715e>//	} else
</span></span></span><span style=display:flex><span><span style=color:#75715e>//		return 0;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>∕</span><span style=color:#a6e22e>internal</span><span style=color:#960050;background-color:#1e0010>∕</span><span style=color:#a6e22e>atomic</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>Cas</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>17</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>ptr</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>BX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>old</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVL</span>	<span style=color:#a6e22e>new</span><span style=color:#f92672>+</span><span style=color:#ae81ff>12</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>CX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>LOCK</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CMPXCHGL</span>	<span style=color:#a6e22e>CX</span>, <span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>BX</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SETEQ</span>	<span style=color:#a6e22e>ret</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><p>从汇编指令可以看出，使用了CPU的<code>LOCK</code>指令来保证原子的操作，而<code>CMPXCHGL</code>指令则是CPU级别实现的CAS操作。</p><p><em>关于LOCK指令，可以发散到CPU指令的锁总线、锁缓存等内容，而CPU会有多级缓存，这就需要通过缓存一致性去保证原子性。而MESI是缓存一致性协议的一种实现方法。</em></p><h3 id=cas不能解决的问题>CAS不能解决的问题
<a class=anchor href=#cas%e4%b8%8d%e8%83%bd%e8%a7%a3%e5%86%b3%e7%9a%84%e9%97%ae%e9%a2%98>#</a></h3><ul><li>CAS在共享资源竞争比较激烈的时候，每个goroutine会容易处于自旋状态，影响效率，在竞争激烈的时候推荐使用锁。</li><li>无法解决ABA问题</li></ul><p>ABA问题是无锁结构实现中常见的一种问题，可基本表述为：
进程P1读取了一个数值A
P1被挂起(时间片耗尽、中断等)，进程P2开始执行
P2修改数值A为数值B，然后又修改回A
P1被唤醒，比较后发现数值A没有变化，程序继续执行。</p><h2 id=swap操作>Swap操作
<a class=anchor href=#swap%e6%93%8d%e4%bd%9c>#</a></h2><p>Swap操作会执行交换操作，并且返回原来的值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>old</span> = <span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span>  <span style=color:#75715e>// 复制原来的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span> = <span style=color:#a6e22e>new</span>  <span style=color:#75715e>// 赋值为新的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>old</span>   <span style=color:#75715e>// 返回原来的值
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>SwapInt32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>int32</span>) (<span style=color:#a6e22e>old</span> <span style=color:#66d9ef>int32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>SwapInt64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>int64</span>) (<span style=color:#a6e22e>old</span> <span style=color:#66d9ef>int64</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>SwapPointer</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>new</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) (<span style=color:#a6e22e>old</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>SwapUint32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>uint32</span>) (<span style=color:#a6e22e>old</span> <span style=color:#66d9ef>uint32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>SwapUint64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>uint64</span>) (<span style=color:#a6e22e>old</span> <span style=color:#66d9ef>uint64</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>SwapUintptr</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>new</span> <span style=color:#66d9ef>uintptr</span>) (<span style=color:#a6e22e>old</span> <span style=color:#66d9ef>uintptr</span>)
</span></span></code></pre></div><h2 id=load操作>Load操作
<a class=anchor href=#load%e6%93%8d%e4%bd%9c>#</a></h2><p>从某个地址里获取对应的值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span>
</span></span></code></pre></div><p>方法签名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadInt32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int32</span>) (<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadInt64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int64</span>) (<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int64</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadPointer</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) (<span style=color:#a6e22e>val</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadUint32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>) (<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uint32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadUint64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint64</span>) (<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uint64</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>LoadUintptr</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>) (<span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uintptr</span>)
</span></span></code></pre></div><h2 id=store操作>Store操作
<a class=anchor href=#store%e6%93%8d%e4%bd%9c>#</a></h2><p>往某个地址里赋值：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>*</span><span style=color:#a6e22e>addr</span> = <span style=color:#a6e22e>val</span>
</span></span></code></pre></div><p>方法签名：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>StoreInt32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int32</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>StoreInt64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>int64</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>StorePointer</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>val</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>StoreUint32</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint32</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uint32</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>StoreUint64</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint64</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uint64</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>StoreUintptr</span>(<span style=color:#a6e22e>addr</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>uintptr</span>)
</span></span></code></pre></div><h2 id=value类型>Value类型
<a class=anchor href=#value%e7%b1%bb%e5%9e%8b>#</a></h2><p>从源码<a href=https://go.googlesource.com/go/+/go1.16.3/src/sync/atomic/value.go#16>https://go.googlesource.com/go/+/go1.16.3/src/sync/atomic/value.go#16</a>可以看到：</p><p>定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Value</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Load</span>() (<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>interface</span>{})
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Store</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>interface</span>{}) 
</span></span></code></pre></div><p>源码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Copyright 2014 The Go Authors. All rights reserved.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Use of this source code is governed by a BSD-style
</span></span></span><span style=display:flex><span><span style=color:#75715e>// license that can be found in the LICENSE file.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>atomic</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// A Value provides an atomic load and store of a consistently typed value.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The zero value for a Value returns nil from Load.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Once Store has been called, a Value must not be copied.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A Value must not be copied after first use.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Value</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>interface</span>{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ifaceWords is interface{} internal representation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ifaceWords</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typ</span>  <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// Load returns the value set by the most recent Store.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// It returns nil if there has been no call to Store for this Value.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Load</span>() (<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>vp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>ifaceWords</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>v</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>typ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>LoadPointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>vp</span>.<span style=color:#a6e22e>typ</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>typ</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> uintptr(<span style=color:#a6e22e>typ</span>) <span style=color:#f92672>==</span> ^uintptr(<span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// First store not yet completed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>LoadPointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>vp</span>.<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>xp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>ifaceWords</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>x</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>xp</span>.<span style=color:#a6e22e>typ</span> = <span style=color:#a6e22e>typ</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>xp</span>.<span style=color:#a6e22e>data</span> = <span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// Store sets the value of the Value to x.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// All calls to Store for a given Value must use values of the same concrete type.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Store of an inconsistent type panics, as does Store(nil).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>v</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Value</span>) <span style=color:#a6e22e>Store</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#e6db74>&#34;sync/atomic: store of nil value into Value&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>vp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>ifaceWords</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>v</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>xp</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>ifaceWords</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>x</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>typ</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>LoadPointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>vp</span>.<span style=color:#a6e22e>typ</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>typ</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Attempt to start first store.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// Disable preemption so that other goroutines can use
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// active spin wait to wait for completion; and so that
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// GC does not see the fake type accidentally.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>runtime_procPin</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>CompareAndSwapPointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>vp</span>.<span style=color:#a6e22e>typ</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(^uintptr(<span style=color:#ae81ff>0</span>))) {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>runtime_procUnpin</span>()
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Complete first store.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>StorePointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>vp</span>.<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>xp</span>.<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>StorePointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>vp</span>.<span style=color:#a6e22e>typ</span>, <span style=color:#a6e22e>xp</span>.<span style=color:#a6e22e>typ</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>runtime_procUnpin</span>()
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> uintptr(<span style=color:#a6e22e>typ</span>) <span style=color:#f92672>==</span> ^uintptr(<span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// First store in progress. Wait.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// Since we disable preemption around the first store,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// we can wait with active spinning.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// First store completed. Check type and overwrite data.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>typ</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>xp</span>.<span style=color:#a6e22e>typ</span> {
</span></span><span style=display:flex><span>			panic(<span style=color:#e6db74>&#34;sync/atomic: store of inconsistently typed value into Value&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>StorePointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>vp</span>.<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>xp</span>.<span style=color:#a6e22e>data</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// Disable/enable preemption, implemented in runtime.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runtime_procPin</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>runtime_procUnpin</span>()
</span></span></code></pre></div><h1 id=应用>应用
<a class=anchor href=#%e5%ba%94%e7%94%a8>#</a></h1><p>atomic.Value这种类型常用于<em>读多写少</em>的场景，比如配置结构体的热更新等。</p><h2 id=例子cowcopy-on-write>例子COW(Copy On Write)
<a class=anchor href=#%e4%be%8b%e5%ad%90cowcopy-on-write>#</a></h2><p>写时复制：（英语：Copy-on-write，简称 COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。</p><p><a href=https://zh.wikipedia.org/wiki/%E5%AF%AB%E5%85%A5%E6%99%82%E8%A4%87%E8%A3%BD>维基百科</a></p><p>通俗的讲就是，需要写入的时候我先把老的数据复制一份到一个新的对象，然后再写入新的值。</p><p>存在的问题：老的对象可能会被其他goroutine使用而导致不回立即被垃圾回收，对于多写的场景会产生大量副本，从而导致性能下降。</p><p>优点：无锁（或者说很轻量的锁），所以也不会有 goroutine 的上下文切换，并且在读取的时候大家都读取的相同的副本所以性能上回好一些。</p><p>COW 策略在 linux， redis 中都有很多的实践。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;sync/atomic&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Map</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span>       <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Value</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//writeMu sync.Mutex
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewMap</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>Map</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>res</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Map</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>v</span>:       <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Value</span>{},
</span></span><span style=display:flex><span>		<span style=color:#75715e>//writeMu: sync.Mutex{},
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>res</span>.<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Store</span>(make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>res</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Map</span>) <span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>key</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Load</span>().(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>m1</span>[<span style=color:#a6e22e>key</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Map</span>) <span style=color:#a6e22e>Put</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//m.writeMu.Lock() // synchronize with other potential writers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//defer m.writeMu.Unlock()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>m1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Load</span>().(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>) <span style=color:#75715e>// load current value of the data structure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>m2</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>string</span>)        <span style=color:#75715e>// create a new value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>m1</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>m2</span>[<span style=color:#a6e22e>k</span>] = <span style=color:#a6e22e>v</span> <span style=color:#75715e>// copy all data from the current object to the new one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m2</span>[<span style=color:#a6e22e>key</span>] = <span style=color:#a6e22e>val</span> <span style=color:#75715e>// do the update that we need
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>v</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#a6e22e>m2</span>) <span style=color:#75715e>// atomically replace the current object with the new one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// At this point all new readers start working with the new version.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// The old version will be garbage collected once the existing readers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// (if any) are done with it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// COW
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewMap</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Put</span>(<span style=color:#e6db74>&#34;key&#34;</span>, <span style=color:#e6db74>&#34;value&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;key&#34;</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#add操作>Add操作</a></li><li><a href=#cas操作>CAS操作</a><ul><li><a href=#cas不能解决的问题>CAS不能解决的问题</a></li></ul></li><li><a href=#swap操作>Swap操作</a></li><li><a href=#load操作>Load操作</a></li><li><a href=#store操作>Store操作</a></li><li><a href=#value类型>Value类型</a></li></ul><ul><li><a href=#例子cowcopy-on-write>例子COW(Copy On Write)</a></li></ul></nav></div></aside></main></body></html>