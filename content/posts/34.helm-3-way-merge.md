---
title: Helm 升级“丢”环境变量？一次彻底的三路合并踩坑实录
date: 2025-03-15
tags:
  - Helm
  - kubernetes
---

## 一、现象复盘

### 1. 安装阶段（helm install）
由于疏忽，我在`values.yaml` 里写上了 `env`，结果在 `deployment.yaml` 模板里 `range` 了一次，结果 YAML 里出现 **同名双份** env：
- 既在 `values.yaml` 里写了
  ```yaml
  env:
    - name: SERVER_IP
      value: "1.2.3.4"
  ```
- 又在 `deployment.yaml` 模板里 `range` 了一次，结果 YAML 里出现 **同名双份** env：
  ```yaml
  env:
  - name: SERVER_IP
    value: "1.2.3.4"
  ...
  - name: SERVER_IP      # 重复
    value: "1.2.3.4"
  ```
- K8s 只认后一条，同时抛警告：
  ```
  spec.template.spec.containers[0].env[11]: hides previous definition of "SERVER_IP"
  ```
此时在k8s的env只存在了一份`SERVER_IP`。

为了消除这个告警消息，我将`values.yaml`里的`SERVER_IP`删掉，但是保留了`template/deployment.yaml`里的`SERVER_IP`。使用`--dry-run`可看到新渲染结果是只存在一个 `SERVER_IP`，符合预期。

然鹅，在第1次执行`helm upgrade`命令升级时，k8s中`SERVER_IP`消失了。同时`--debug`返回的渲染结果的确有一个 `SERVER_IP`。
第二次执行`helm upgrade`命令时，k8s中`SERVER_IP`又出现了，符合预期。


### 2. 疑问
1. 为什么第一次升级会把 env **全删光**？
2. `--dry-run=server`、 `--post-renderer` 为何也看不出“被删”的证据？
3. Helm 到底把什么发给了 apiserver？

---

## 二、Helm 渲染与提交的三段流水线

| 阶段 | 内容 | 可见开关 |
| ---- | ---- | -------- |
| ① 模板渲染 | go-template 输出完整 YAML | `--debug`、 `--dry-run`、 `--post-renderer` |
| ② 3-way merge | 本地计算 strategic-merge-patch | **无官方开关**（下文给办法） |
| ③ 调用 K8s | 把 patch/apply 发给 apiserver | `--v=6` 可打印 PATCH 体 |

---

## 三、3-way merge 到底在合并什么

Helm 取三份数据：

1. **旧 manifest**（上一次 release 存在 Secret 里）
2. **新 manifest**（阶段 ① 的输出）
3. **live object**（当前集群真实状态）

算法简化为：

- 新 manifest **有** 且 旧/live **无** → 新增
- 新 manifest **无** 且 旧/live **有** → **删除**（patch 里给 `null` 或整项移除）
- 其它情况保留/合并

**第一次升级时：**

- 旧 & live：因为曾经双份，K8s 只保留一条 SERVER_IP
- 新 manifest：**1 条** SERVER_IP
- 合并结论 → “用户要删”，于是产生
  ```json
  "env":[{"$patch":"delete","name":"SERVER_IP"}]
  ```
  最终 apiserver 收到的是 **“把这项摘掉”**。
```
旧 manifest 快照(2条) ───────┐
                            ├─ 3-way merge ─→ patch 含 delete → 集群侧 env 被 delete
live object (1条)  ─────────┤
新 manifest (1条，修复后) ───┘
↑
只要旧 manifest 里还是 2 条，就永远会触发 delete
```

**第二次升级时：**

- live 里已没有 SERVER_IP，基准为空，不会产生 remove 操作，结果保持缺席。


---

## 四、为什么 `--dry-run=server` 也看不到“patch”

- `--dry-run=server` 只是把 **阶段 ① 的全量 YAML** 丢给 apiserver **DryRun** 接口做**校验**。
- StrategicMergePatch 的计算仍在 **Helm 本地完成**，客户端不会把“差分”回显给你。
- 因此你能看到的仍是“全量”而非 patch；若某项被删，全量里就**直接没有**，看上去就像“消失”。

---

## 五、如何亲手抓到真正的 patch

### 1. 打开 Helm 的 kube-client 调试日志
```bash
helm upgrade demo ./chart -n cloud --v=6
```
日志会输出类似
```
client.go:693: [debug] Patch Deployment "notify" in namespace cloud
I0908 10:09:08.651304 1679687 request.go:1212] Request Body: {"spec":{"replicas":2,"strategy":null,"template":{"spec":{"$setElementOrder/containers":[{"name":"notify"}],"$setElementOrder/initContainers":[{"name":"init-lib"},{"name":"init-app"}],"affinity":{"podAntiAffinity":{"requiredDuringSchedulingIgnoredDuringExecution":[{"labelSelector":{"matchExpressions":[{"key":"app.kubernetes.io/name","operator":"In","values":["notify"]}]},"topologyKey":"kubernetes.io/hostname"}]}},"containers":[{"$setElementOrder/env":[{"name":"EUREKA_OPTS"},{"name":"SERVER_IP"},{"name":"MIN_HEAP_SIZE"},{"name":"MAX_HEAP_SIZE"},{"name":"STACK_SIZE"},{"name":"META_SIZE"},{"name":"MAX_META_SIZE"},{"name":"JAVA_OPTS"},{"name":"REDIS_SENTINEL_NODES"},{"name":"DEBUG"},{"name":"EXTEND_JAVA_OPTS"}],"env":[{"$patch":"delete","name":"SERVER_IP"}],"image":"xxx","name":"notify"}],"initContainers":[{"image":"xxx","name":"init-lib"},{"image":"xxx","name":"init-app"}]}}}}
I0908 10:09:08.651430 1679687 round_trippers.go:466] curl -v -XPATCH  -H "Accept: application/json" -H "Content-Type: application/strategic-merge-patch+json" -H "User-Agent: Helm/3.14.0" 'https://127.0.0.1:6443/apis/apps/v1/namespaces/cloud/deployments/notify?fieldManager=helm'
I0908 10:09:08.735670 1679687 round_trippers.go:553] PATCH https://127.0.0.1:6443/apis/apps/v1/namespaces/cloud/deployments/notify?fieldManager=helm 200 OK in 84 milliseconds
```
这里可清楚看到 Helm 发的是 **PATH** 而非全量 PUT。


### 2. 审计日志 / 抓包
开启 apiserver 的 **Audit** 或给 kube-apiserver 抓包，Content-Type 为  
`application/strategic-merge-patch+json` 的 PATCH 体即是最终 patch。

---

## 六、避坑指南

1. **根本方案**  
   不要在 values 和模板里同时 `range` / 硬编码同名 env；用字典去重或只保留一份数据源。

2. **想“强制覆盖”而非“合并”**  
   模板里显式把不要的 env 置 `null`：
   ```yaml
   - name: SERVER_IP
     value: null
   ```
   这样 merge 会识别为“字段清空”，不会误删其它 env。

3. **需要跳过 3-way merge**  
   升级时加 `--force`（Helm 3），Helm 会直接 PUT 全量对象；  
   ⚠️ 会丢失任何在集群侧做的在线修改，生产慎用。
---

## 七、一张图总结

```
┌----------------------┐
| ① template rendering | ← --debug / --dry-run / --post-renderer 只看得到这里
└---------┬------------┘
          |
          ▼
┌----------------------┐
| ② 3-way merge        | ← 真正决定“增/删/改”的黑暗阶段，无官方开关
|   (strategic patch)  |
└---------┬------------┘
          |
          ▼
┌----------------------┐
| ③ PATCH/PUT          | ← --v=6 可抓包；audit log 可见
|   to kube-apiserver  |
└----------------------┘
```

---

## 八、结语

Helm 的 `--debug` / `--dry-run` 只能让你看到“模板长什么样”，**真正的 diff 发生在本地 3-way merge**。  
当发现“渲染有、集群无”时，九成是合并阶段把字段判为“删除”。  
 **“模板输出 ≠ 最终 patch”**，配合 `--v=6` 等工具，就能把“幽灵消失”的字段抓个现行。
